[{"path":[]},{"path":"/articles/Model_Parameters.html","id":"coxtp","dir":"Articles","previous_headings":"1. Functions","what":"1.1 coxtp:","title":"Model Parameters","text":"coxtp(event,z,time,strata=c(),spline=\"P-spline\", nsplines=8, ties=\"Breslow\",tol=1e-9, iter.max=20L, method=\"Newton\", lambda=1e8,factor=10, btr=\"dynamic\", sigma=1e-2, tau=0.6,stop=\"incre\", parallel=FALSE, threads=1L, degree=3L, TIC = FALSE, TIC_prox = FALSE, lambda_spline = 0, ord = 4, fixedstep = FALSE, effectsize = 0, difflambda = FALSE,addsecond = FALSE, penalizestop = FALSE, ICLastOnly = FALSE) main function package coxtp refers “Cox Non-proportional Hazards model penalization”.","code":""},{"path":"/articles/Model_Parameters.html","id":"common-parameters","dir":"Articles","previous_headings":"1. Functions > 1.1 coxtp:","what":"1.1.1 Common Parameters","title":"Model Parameters","text":"coxtp function two required input, formula data. event: Event vector, vector containing 0 1 z: Covariate matrix time: Time vector, vector non-negative numeric value strata: stratification group defined data. exist stratification group, please enter vector.","code":""},{"path":"/articles/Model_Parameters.html","id":"method-related-parameters","dir":"Articles","previous_headings":"1. Functions > 1.1 coxtp:","what":"1.1.2 Method related Parameters:","title":"Model Parameters","text":"offered model estimation penalization without penalization. Detail method found paper(add link ). Following parameters defines model settings: spline: spline term Penalized Newton’s Method(Add section Number related paper). Default setting spline=\"Smooth-spline\" \"P-spline\": P-splines low rank smoother using B-spline basis. Detail information P-spline found (Add section number link) \"Smooth-spline\" : (Add section number link) nsplines : Number base functions B-splines, default 8. method : Selecting Method used, default method=\"Newton\" \"Newton\": Usual Newton’s Approach. \"ProxN\" : Proximal Newton–Raphson Method proposed paper(get link ). lambda : Parameter Proximal Newton’s Method. Default lambda=1e8 tau : (Alpha beta?) Newton’s Method, Default tau=0.5. Used control step size. lambda_spline : Smoothing parameter lambda. Default lambda_spline = 0 refers Newton’s Method without penalization. degree: Degree smoothing spline. Default setting degree=3L. degree=2L refers Smoothing quadratic spline. degree=3L refers Smoothing cubic spline. ord : Specify derivative penalize. Default setting ord=4. ord=4: Penalized second order derivative, suggest use using smoothing cubic spline. ord=3: Penalized first order derivative, suggest use using smoothing quadratic spline. penalizestop: delete","code":""},{"path":"/articles/Model_Parameters.html","id":"stopping-creteria-related-parameters","dir":"Articles","previous_headings":"1. Functions > 1.1 coxtp:","what":"1.1.3 Stopping creteria related Parameters:","title":"Model Parameters","text":"tol: Convergence threshold. default threshold set tol=1e-6 iter.max: Maximum Iteration number, default iter.max=20L incre: define \\((l^{(m)}-l^{(m-1)})/(l^{(m)}-l^{(0)})\\) relative change log-partial likelihood, m denotes mth step algorithm. ’s smaller certain threshold, stop algorithm. tol variable determining convergence threshold. relch: define relative change log-partial likelihood \\((l^{(m)}-l^{(m-1)})/(l^{(m)})\\), makes easier converge. incre: method stop algorithm half Newton increment less threshold(tol defined previous argument?? correct??). fixedstep: might times stopping criteria working, thus, number steps set manually. Default value fixedstep = FALSE, true, stop iter.max","code":""},{"path":"/articles/Model_Parameters.html","id":"other-parameters","dir":"Articles","previous_headings":"1. Functions > 1.1 coxtp:","what":"1.1.4 Other Parameters:","title":"Model Parameters","text":"\"Breslow\": Breslow approximation. Detailed information found (add link) \"none: Don’t deal ties \"none\": Don’t Backtracking Linesearch. \"static\" : binary predictors extremely low frequency present, calculation second order derivative issues. case, Newton increment presents extreme values, leading huge bias. provided way limiting step size cases. Instead using Newton increment, use fixed value 1. method referred “static” function. Since moves slower, usually can achieve maximum likelihood estimator, leading biased estimation. \"dynamic\" : Backtracking Linesearch Newton Increment. Detail information found (Add link) parallel: Parallel computation, Default parallel=FALSE threads : Parallel computation parameter(number cores)Default threads=1L TIC_prox : calculating information criteria, might numerical issue(second order derivative, Hessian matrix approximate singular), thus proposed add small term diagonal. Default TIC_prox = FALSE ICLastOnly : calculate last information criteria TRUE. Default ICLastOnly=FALSE","code":""},{"path":"/articles/Model_Parameters.html","id":"coxtp-plot","dir":"Articles","previous_headings":"1. Functions","what":"1.2. coxtp.plot","title":"Model Parameters","text":"coxtp.plot(fit,IC=\"AIC\",coef,xlab=\"Time\",ylab=\"Hazard Ratio (log-scale)\") Function coxtp.plot created generate related hazard ratio plot result generated coxtp fit: Model fitted coxtp IC=“TIC”: Takeuchi information criterion (Insert link ) IC=“GIC”: Generalized information criterion (Insert link ) IC=“AIC”: Akakia information criterion (Insert link ) coef: variable needed plotted xlab: X axis label, default xlab=“Time” ylab: X axis label, default ylab=“Hazard Ratio (log-scale)”","code":""},{"path":"/articles/Model_Parameters.html","id":"coxtp-baseline","dir":"Articles","previous_headings":"1. Functions","what":"1.3. coxtp.baseline","title":"Model Parameters","text":"coxtp.baseline(fit, delta,z,time,strata=c()) fit: Model fitted coxtp delta: Event vector, vector containing 0 1 z: Covariate matrix time: Time vector, vector non-negative numeric value. strata: stratification group defined data. exist stratification group, please enter vector.","code":""},{"path":[]},{"path":"/articles/Model_Parameters.html","id":"sim_data","dir":"Articles","previous_headings":"2. Data sets","what":"2.1 sim_data","title":"Model Parameters","text":"Example data surtvep 5000 observations 4 variables V1: Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1} V2: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5*t)} event: Simulated event variable, Binary varible 0, 1 } time: Simulated time variable, Continous variable non-negative value}","code":""},{"path":"/articles/Model_Parameters.html","id":"sim_data_p5","dir":"Articles","previous_headings":"2. Data sets","what":"2.2 sim_data_p5","title":"Model Parameters","text":"Example data surtvep 5000 observations 7 variables: V1: Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1} V2: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=sin(3t/4)} V3: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=-1} V4: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=(t/3)**2 V5: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5}t)} event: Simulated event variable, Binary varible 0, 1 } time: Simulated time variable, Continous variable non-negative value}","code":""},{"path":"/articles/Model_Parameters.html","id":"sim_data_p5_f5","dir":"Articles","previous_headings":"2. Data sets","what":"2.3 sim_data_p5_f5","title":"Model Parameters","text":"Example data surtvep 5000 observations 8 variables(strata): V1: Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1} V2: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=sin(3t/4)} V3: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=-1} V4: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=(t/3)**2 V5: Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5}t)} event: Simulated event variable, Binary varible 0, 1 } time: Simulated time variable, Continous variable non-negative value} facility: Simulated stratification variable. 5 levels}","code":""},{"path":"/articles/surtvep.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction:","title":"Introduction to surtvep","text":"Coxtp R package fitting penalized Newton’s method time-varying effects model using mAIC, TIC, GIC information criteria, particular span parameter using basis functions. Utilities carrying post-fitting visualization, summarization, inference also provided.","code":""},{"path":"/articles/surtvep.html","id":"installation","dir":"Articles","previous_headings":"","what":"2. Installation:","title":"Introduction to surtvep","text":"","code":"#Install the package, need to install the devtools packages: install.packages(\"devtools\") devtools::install_github(\"UM-KevinHe/surtvep\")  #To install with Vignettes: install.packages(\"devtools\") devtools::install_github(\"UM-KevinHe/surtvep\",build_vignettes =T) library(surtvep) #> Loading required package: ggplot2 #> Loading required package: splines2 #> Warning: package 'splines2' was built under R version 4.1.3"},{"path":"/articles/surtvep.html","id":"dataset-preperation","dir":"Articles","previous_headings":"","what":"3. Dataset preperation:","title":"Introduction to surtvep","text":"purpose demonstration, use simulated dataset “sim_data” package. Let’s check data first: , covariates V1 V2 generated binary variables around 90% frequency. related true log-hazard function variable \\(\\beta(t)=1\\) \\(\\beta(t)=exp(-1.5*t)\\), t denotes time. , let’s extract time event vector, get remaining information dataset matrix.","code":"sim_data=sim_data head(sim_data) #>      V1 V2 event         time #> [1,]  0  0     1 0.0003028248 #> [2,]  0  0     1 0.0004273569 #> [3,]  0  0     0 0.0008948164 #> [4,]  0  0     1 0.0008981023 #> [5,]  0  0     0 0.0009103830 #> [6,]  0  0     1 0.0010759157 event=sim_data[,\"event\"] time=sim_data[,\"time\"] data=sim_data[,!colnames(sim_data) %in% c(\"event\",\"time\")]"},{"path":[]},{"path":[]},{"path":"/articles/surtvep.html","id":"simple-fitting","dir":"Articles","previous_headings":"4. Model fitting > 4.1 Newton Method without penalization:","what":"4.1.1 Simple fitting:","title":"Introduction to surtvep","text":"Let’s fit model. , default method Newton Method without penalization, smooth-spline. Term lambda_spline refers smoothing parameter lambda (Detail found “Model parameter” section paper (Modified XuTao’s site finished). Default value lambda_spline=0, refers penalization). number knots base function default nsplines=8 get estimated time-varying effect specific coefficient, use following plot function package:  plot shows result time-varying effect Variable “V2”.","code":"fit <- coxtp(event = event, z = data, time = time) coxtp.plot(fit,coef=\"V2\")"},{"path":[]},{"path":"/articles/surtvep.html","id":"model-results-meanings","dir":"Articles","previous_headings":"4. Model fitting > 4.1 Newton Method without penalization: > 4.1.2 Detailed calculations and theories.","what":"4.1.2.1 Model results meanings:","title":"Introduction to surtvep","text":"First, Let’s look fit result 4 results saved fit result. model_result save detailed model results explain minute. lambda.selected saved best lambda chosen based different criteria used non-penalized model. p refers number covariates used model z_names records covariates names. detailed model result saved model_result, can called fit$model_result. Now, let’s explore result little bit: noticed 18 items model results list. Following explanation item: theta: Estimation matrix \\(\\theta\\) logplkd: log-partial likelihood theta_all: Internal validation use theta_list: estimation matrix Newton’s update AIC_all: Akakia information criterion TIC_all: Takeuchi information criterion TIC2_all: Internal validation use GIC_all: Generalized information criterion AIC_trace: Internal validation use TIC_trace: Internal validation use TIC2_trace: Internal validation use GIC_trace: Internal validation use logplkd_vec: log-partial likelihood iteration SplineType: spline used fitting model VarianceMatrix: Variance Matrix uniqfailtimes: input unique event times ties=\"Breslow\", input time points ties=\"None\" (Add link) bases: basis function used estimating time-varying effects knots: Number basis functions used estimating time-varying effects","code":"summary(fit) #>                 Length Class      Mode      #> model_result    18     -none-     list      #> lambda.selected  1     data.frame list      #> p                1     -none-     numeric   #> z_names          2     -none-     character summary(fit$model_result) #>                Length Class  Mode      #> theta             16  -none- numeric   #> logplkd            1  -none- numeric   #> theta_all         16  -none- numeric   #> theta_list         3  -none- list      #> AIC_all            1  -none- numeric   #> TIC_all            1  -none- numeric   #> TIC2_all           1  -none- numeric   #> GIC_all            1  -none- numeric   #> AIC_trace          1  -none- numeric   #> TIC_trace          1  -none- numeric   #> TIC2_trace         1  -none- numeric   #> GIC_trace          1  -none- numeric   #> logplkd_vec        1  -none- numeric   #> SplineType         1  -none- character #> VarianceMatrix   256  -none- numeric   #> uniqfailtimes   2487  -none- numeric   #> bases          19896  bs     numeric   #> knots              4  -none- numeric"},{"path":"/articles/surtvep.html","id":"how-to-get-the-effect-of-a-specific-time-point","dir":"Articles","previous_headings":"4. Model fitting > 4.1 Newton Method without penalization: > 4.1.2 Detailed calculations and theories.","what":"4.1.2.2: How to get the effect of a specific time point?","title":"Introduction to surtvep","text":"interested estimating time-varying effect covariates. Following simple tutorial . First, little background time-varying effect cox model(also check part paper detailed explanation.(insert link)) Let \\(X_i=(X_{i1},X_{i2},...X_{ip})^T\\) refers \\(i_{th}\\) individuals dataset p covariates(also understand \\(i_{th}\\) row data extract ). Let \\(\\lambda(t|X_i)\\) denote hazard event time t \\(i_{th}\\) individual, \\(\\lambda_0(t)\\) denote hazard event time 0. considering covarites time fixed effect, following formula \\(\\lambda(t|X_i)\\): \\(\\lambda(t|X_i)=\\lambda_0(t)exp(X_i^T\\beta)\\) \\(\\beta\\) refers coefficients \\(\\beta=(\\beta_1,\\beta_2,...\\beta_p)\\), example, (V1, V2). similar format GLM model. time-varying effect model, simply replace \\(\\beta\\) set \\(\\beta(t)\\). Thus, time varying equations transferred following: \\(\\lambda(t|X_i)=\\lambda_0(t)exp(X_i^T\\beta(t))\\) Similar, \\(\\beta(t)=(\\beta_1(t),\\beta_2(t),...\\beta_p(t))\\) \\(\\beta(.)\\) refers set cubic B-spline(Details B-spline refers : insert link). , single \\(\\beta_p(t)\\) estimated using following formula: \\(\\beta_p(t)=\\theta_p^TB(t)=\\sum_{k=1}^K\\theta_{pk}B_k(t)\\) , K refers given number knots. Thus, calculate time varying effect coefficient p, just need get estimated B spline \\(\\theta\\) matrix. B-spline saved model_result$bases \\(\\theta\\) matrix saved last item model_result$theta_list Following code calculation: result, \\(\\beta\\) 2487*2 matrix(using “Breslow” ties, thus 2487 rows instead 5000, detail ties Breslow ties refers (insert link)). also get 95%CI estimation, calculates : matrix beta_low records lower bound beta beta_up records upper bound beta. result, plot effect :","code":"model_result  = fit$model_result B.spline      = as.matrix(model_result$bases) theta         = model_result$theta_list[[length(model_result$theta_list)]]  beta          = B.spline %*% t(theta)  dim(beta) #> [1] 2487    2 head(beta) #>           [,1]     [,2] #> [1,] 0.4574157 1.165634 #> [2,] 0.4593697 1.165002 #> [3,] 0.4667205 1.162619 #> [4,] 0.4694825 1.161720 #> [5,] 0.4751800 1.159862 #> [6,] 0.4809900 1.157959 B.spline <- as.matrix(model_result$bases)   theta_plot  <- model_result$theta_list[[length(model_result$theta_list)]]  beta     <- B.spline%*%t(theta_plot) var      <-  model_result$VarianceMatrix  colnames(beta)=fit$z_names p        <- fit$p knot     <- dim(B.spline)[2] list     <- 1:dim(B.spline)[1] beta_low <- matrix(0,dim(B.spline)[1],p) beta_up  <- matrix(0,dim(B.spline)[1],p) for(i in 1:p){   beta_t_1   <- beta[,i]   var2       <- var[((i-1)*knot+1):((i-1)*knot+knot),((i-1)*knot+1):((i-1)*knot+knot)]   temp       <- 1.96*sqrt(vapply(list, function(x) matrix(B.spline[x,],1,knot)%*%var2%*%t(matrix(B.spline[x,],1,knot)),FUN.VALUE=numeric(1)))   low        <- beta_t_1-temp   up         <- beta_t_1+temp      beta_low[,i] <- low   beta_up[,i]  <- up }  colnames(beta_low) <- paste0(fit$z_names,\"_low\") colnames(beta_up) <- paste0(fit$z_names,\"_up\")  head(beta_low) #>          V1_low    V2_low #> [1,] -0.3067298 0.4644817 #> [2,] -0.3023110 0.4662445 #> [3,] -0.2857054 0.4728474 #> [4,] -0.2794734 0.4753164 #> [5,] -0.2666307 0.4803885 #> [6,] -0.2535532 0.4855309 head(beta_up) #>         V1_up    V2_up #> [1,] 1.221561 1.866786 #> [2,] 1.221050 1.863760 #> [3,] 1.219146 1.852390 #> [4,] 1.218438 1.848125 #> [5,] 1.216991 1.839335 #> [6,] 1.215533 1.830388 beta              <- as.data.frame(beta) beta              <- cbind(beta, beta_low, beta_up) y=beta$V2 ymin=beta$V2_low ymax=beta$V2_up time=model_result$uniqfailtimes   ggplot(data=beta, aes(x=time)) +    geom_line(aes(y= y),size = 0.9,color = 'red') +    geom_ribbon(aes(ymin = ymin, ymax = ymax), fill=\"red\", alpha = 0.2) +    scale_y_continuous(name='Hazard Ratio (log-scale)') +   theme_bw() +  theme(plot.title = element_text(hjust = 0.5)) +   theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank()) +   theme(text= element_text(size=14)) + theme(axis.text= element_text(size=14)) +   theme(axis.title.y = element_text(margin= margin(t=0, r=10, b=0, l=0))) +labs(x=\"Time\") +    ggtitle(paste0(\"Effect of V2 When holding other covariates constant\"))"},{"path":"/articles/surtvep.html","id":"newton-method-with-penalization","dir":"Articles","previous_headings":"4. Model fitting","what":"4.2 Newton Method with penalization:","title":"Introduction to surtvep","text":"use smooth spline penalization(default). also use spline=\"P-spline\". lambda_spline, either enter numeric number(must integer) vector numbers. lambda_spline entered vector numbers, best lambda selected based different criteria(AIC, TIC GIC). lambda_spline entered single number, model result format kind similar 4.1, model result called model_result. Following model fit lambda_spline vector different illustration purposes: optimal lambda saved model term lambda.selected result , noticed different selection criteria, best lambda selected quite different. , use AIC criteria set lambda=1000. result model saved related criteria model called : also directly draw plot using following command:  Compare non-penalized Model, see effect “V1” shrink roughly linear penalized model. detail calculation B-spline matrix, \\(\\theta\\) matrix \\(\\beta\\) matrix similar illustrate 4.1.2.2.","code":"time=sim_data[,\"time\"] lambda_spline_all=c(0.001,0.01,0.1,1,10,100,1000) fit_penalized <- coxtp(event = event, z = data, time = time,lambda_spline=lambda_spline_all) best_lambda=fit_penalized$lambda.selected best_lambda #>     value #> AIC  1000 #> TIC   100 #> GIC  1000 AIC_model  = fit_penalized$model.AIC summary(AIC_model) #>                Length Class  Mode      #> theta             16  -none- numeric   #> logplkd            1  -none- numeric   #> theta_all         16  -none- numeric   #> theta_list         3  -none- list      #> AIC_all            1  -none- numeric   #> TIC_all            1  -none- numeric   #> TIC2_all           1  -none- numeric   #> GIC_all            1  -none- numeric   #> AIC_trace          1  -none- numeric   #> TIC_trace          1  -none- numeric   #> TIC2_trace         1  -none- numeric   #> GIC_trace          1  -none- numeric   #> logplkd_vec        1  -none- numeric   #> SplineType         1  -none- character #> VarianceMatrix   256  -none- numeric   #> uniqfailtimes   2487  -none- numeric   #> bases          19896  bs     numeric   #> knots              4  -none- numeric library(cowplot) x=seq(0,3,length.out=2487) y1=1 y2=exp(-1.5*x) p1=coxtp.plot(fit_penalized,IC=\"AIC\",coef=\"V1\") +      ggtitle(\"Penalized NR\") + geom_line(aes(x=x,y=y1))  p2=coxtp.plot(fit,IC=\"AIC\",coef=\"V1\") +      ggtitle(\"Non-Penalized NR\")+ geom_line(aes(x=x,y=y1))  plot_grid(p1,p2)"},{"path":[]},{"path":"/articles/surtvep.html","id":"backtracking-linesearch","dir":"Articles","previous_headings":"4. Model fitting > 5. Other information","what":"5.1 Backtracking Linesearch","title":"Introduction to surtvep","text":"packages, provide 3 options backtracking linesearch(btr). usual way backtracking linesearch Newton Increment(Detailed information found ). However, binary predictors extremely low frequency present, calculation second-order derivative issues. case, Newton increment presents extreme values, leading huge bias. provided way limiting step size cases. Instead using Newton increment, use fixed value 1. method referred “static” function default setting. Besides , btr=\"none\" refers backtracking, btr=\"dynamic\" refers backtracking linesearch Newton Increment. Following comparison three methods regards accuracy : Compared dynamic static, backtracking linesearch gives optimal programming time. Following performance method:","code":"# For no backtracking linesearch: t1=bench::mark(coxtp(event = event, z = data,                    time = time,lambda_spline=1000,btr=\"none\"))  #For static backtracking linesearch: t2=bench::mark(coxtp(event = event, z = data,                    time = time,lambda_spline=1000,btr=\"static\"))  #For dynamic backtracking linesearch: t3= bench::mark(coxtp(event = event, z = data,                    time = time,lambda_spline=1000,btr=\"dynamic\")) t=rbind(t1,t2,t3) t[,1]=c(\"none\",\"static\",\"dynamic\") t #> # A tibble: 3 x 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <chr>      <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 none           1.9s     1.9s    0.526     50.8MB   1.05   #> 2 static        4.67s    4.67s    0.214     51.6MB   0.214  #> 3 dynamic      10.24s   10.24s    0.0976    52.8MB   0.0976 time_list=c() x=seq(0,3,length.out=2487) y1=1 y2=exp(-1.5*x)  for(btr in c(\"none\",\"dynamic\",\"static\")){   fit=coxtp(event = event, z = data, time = time,lambda_spline=1000,btr=btr)   for(v in c(\"V1\",\"V2\")){     plot=coxtp.plot(fit,IC=\"AIC\",coef=v,ylab=\"HR(log-scale)\")+      theme(text = element_text(size = 10),           axis.text.x = element_text(size = 8),           axis.text.y=element_text(size = 8)) +      ggtitle(v)     if(v==\"V1\"){       plot=plot + geom_line(aes(x=x,y=y1))      } else {       plot=plot + geom_line(aes(x=x,y=y2))      }     assign(paste0(\"plot\",v,\"_\",btr),plot)   }  } library(cowplot) ##Plot v1 title <- ggdraw() +    draw_label(     \"Backtracking comparsion\",     fontface = 'bold',     x = 0,     hjust = 0,     size=15   ) +   theme(     plot.margin = margin(0, 0, 0, 7)   )  p1=plot_grid(plotV1_none,plotV2_none,ncol=2) p2=plot_grid(plotV1_dynamic,plotV2_dynamic,ncol=2) p3=plot_grid(plotV1_static,plotV2_static,ncol=2) plot_grid(title,p1,p2,p3,ncol=1,labels=c(\"\",\"None\",\"Dynamic\",\"Static\"),rel_heights = c(0.1,1,1,1),label_size = 13)"},{"path":"/articles/surtvep.html","id":"stopping-criteria","dir":"Articles","previous_headings":"4. Model fitting > 5. Other information","what":"5.2 Stopping criteria","title":"Introduction to surtvep","text":"4 parameters defined stopping criteria, Convergence threshold(tol ), Maximum Iteration number(iter.max), Stopping rule(stop), number steps(fixedstep). Detailed information stopping criteria selection viewed (add link). Following default setting coxtp(...,tol=1e-6,iter.max=20L,stop=\"ratch\",fixedstep=FALSE)","code":""},{"path":"/articles/surtvep.html","id":"baseline-estimation","dir":"Articles","previous_headings":"4. Model fitting > 5. Other information","what":"5.3 Baseline estimation","title":"Introduction to surtvep","text":"baseline estimation refers baseline hazard time t holding covariates equals zero. calculated calling coxtp.baseline function","code":"#Fit the model first: event=sim_data[,\"event\"] time=sim_data[,\"time\"] data=sim_data[,!colnames(sim_data) %in% c(\"event\",\"time\")]  lambda_spline_all=c(0.001,0.01,0.1,1,10,100,1000) fit_penalized <- coxtp(event = event, z = data, time = time,lambda_spline=lambda_spline_all)  model1  = fit_penalized$model.AIC  ##baseline plotdata=coxtp.baseline(fit=model1, delta=event,z=data,time=time) #Exclude censoring points plotdata=plotdata[plotdata$lambda!=0,]  baseline_plot<-ggplot(plotdata,aes(x=unique.time., y=lambda)) + geom_line(size = 0.6) +     scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) +   scale_y_continuous(name='baseline hazard', limits=c(0,0.1)) +   ggtitle(\" Baseline Hazard by time\") +   theme(plot.title = element_text(hjust = 0.5)) baseline_plot"},{"path":[]},{"path":"/articles/surtvep.html","id":"stratification","dir":"Articles","previous_headings":"4. Model fitting > 5. Other information","what":"5.5 Stratification","title":"Introduction to surtvep","text":"handle different stratification groups dataset, packages use facility risk sets finish estimation. add strata model, simply use strata option. Following example: , using sim_data_p5_f5 example. dataset 5 covariates, “V1” “V5”, strata variable, “facility”. dataset, true time-dependent function V1: \\(\\beta(t)=1\\) V2: \\(\\beta(t)=sin(3*\\pi*t/4)\\) V3: \\(\\beta(t)=-1\\) V4: \\(\\beta(t)=(t/3)**2*exp(t/2)\\) V5: \\(\\beta(t)=exp(-1.5*t)\\) Now, let’s fit model simply add one option strata =facility. black line plot refers true function red line area refers estimated function 95% CI. , use coxtp.baseline function get baseline estimation different group. Just add option strata=facility get specific facility data","code":"sim_data_p5_f5=sim_data_p5_f5 head(sim_data_p5_f5) #>      V1 V2 V3 V4 V5 event         time facility #> [1,]  0  0  0  0  0     0 4.018354e-05        2 #> [2,]  0  0  1  1  1     1 2.103197e-04        2 #> [3,]  0  0  0  1  1     1 2.281676e-04        5 #> [4,]  0  0  0  0  1     1 4.334258e-04        3 #> [5,]  0  0  0  1  1     1 5.608086e-04        4 #> [6,]  1  0  0  0  0     1 5.623171e-04        1 #Extract data event_stra=sim_data_p5_f5[,\"event\"] time_stra=sim_data_p5_f5[,\"time\"] data_stra=sim_data_p5_f5[,!colnames(sim_data_p5_f5) %in% c(\"event\",\"time\",\"facility\")] facility=sim_data_p5_f5[,\"facility\"]  #select best lambda lambda_spline_all=c(0.001,0.01,0.1,1,10,100,1000) fit_stra<-coxtp(event=event_stra,z=data_stra,time=time_stra,strata =facility,lambda_spline=lambda_spline_all) library(dplyr) model1  = fit_stra$model.AIC baselinedata=coxtp.baseline(fit=model1, delta=event_stra,z=data_stra,time=time_stra,strata = facility) baselinedata=baselinedata %>%   filter(lambda!=0) %>%   mutate(facility=as.character(strata)) baseline_plot<-ggplot(baselinedata,aes(x=unique.time_temp., y=lambda,group=facility)) + geom_line(size = 0.6,aes(color=facility)) +     scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) +   scale_y_continuous(name='baseline hazard') +   ggtitle(\" Baseline Hazard by time and facility\") +   theme(plot.title = element_text(hjust = 0.5)) baseline_plot"},{"path":[]},{"path":[]},{"path":"/articles/surtvep.html","id":"accurancy","dir":"Articles","previous_headings":"4. Model fitting > 6. Model performance > 6.1 Internal comparison","what":"6.6.1 Accurancy:","title":"Introduction to surtvep","text":"non-penalized method, estimation largely depended number knots chosen B-Spline base function. example shown using default knots, nspline=8. However, estimation largely different choose knots. Following code showing performance estimation choosing different knots: Following code showing performance estimation choosing different knots: result , red line shadow refer estimated function 95%CI black line refers true function time-fixed(y=1). result , noticed knots increase, estimation becomes inaccurate. happening number knots increases, variance data mistakenly captured influence. makes number knots selection non-penalized model important. penalized model, since penalized term, number knots didn’t matters much, instead, \\(\\lambda\\) important. Following plot performance estimation use lambda_spline selected , lambda_spline= 1000 plot , observe different knots selected, performance different much different knots, estimates relatively close real function. However, penalized model, lambda important another reason need select best lambda actually fitting model. following plot performance different lambda selected. following plot, knot set default, knot=8. result, lambda increase, estimated function related true function. happening true function time-fixed function, thus, lambda increase, real function tends shrink fixed function.","code":"knot_list=c(6,8,10,20) labels=paste0(\"Knots=\",knot_list) x=seq(0,3,length.out=2487) y=1 for(knot in knot_list){   fit<-coxtp(event=event,z=data,time=time,nspline=knot)   plot<-coxtp.plot(fit,coef=\"V1\",ylab=\"HR(log-scale)\") +      theme(text = element_text(size = 10),           axis.text.x = element_text(size = 8),           axis.text.y=element_text(size = 8)) +      ggtitle(\"\") + geom_line(aes(x=x,y=y))      plot   assign(paste0(\"plot\",knot),plot) }  library(cowplot)   title <- ggdraw() +    draw_label(     \"Non-penalized NR\",     fontface = 'bold',     x = 0,     hjust = 0,     size=15   ) +   theme(     plot.margin = margin(0, 0, 0, 7)   ) p1=plot_grid(plot6,plot8,plot10,plot20,ncol=2,labels=c(labels),label_size = 13) p1 knot_list=c(6,8,10,20) labels=paste0(\"Knots=\",knot_list) x=seq(0,3,length.out=2487) y=1 for(knot in knot_list){   fit<-coxtp(event=event,z=data,time=time,nspline=knot,lambda_spline = 1000)   plot<-coxtp.plot(fit,coef=\"V1\",ylab=\"HR(log-scale)\") +      theme(text = element_text(size = 10),           axis.text.x = element_text(size = 8),           axis.text.y=element_text(size = 8)) +      ggtitle(\"\") +      geom_line(aes(x=x,y=y))    plot   assign(paste0(\"plot\",knot),plot) } library(cowplot)  title <- ggdraw() +    draw_label(     paste0(\"Penalized NR,lambda=\",1000),     fontface = 'bold',     x = 0,     hjust = 0,     size=15   ) +   theme(     plot.margin = margin(0, 0, 0, 7)   ) p1=plot_grid(plot6,plot8,plot10,plot20,ncol=2,labels=c(labels),label_size = 13) p1 lambda_spline_all=c(0.001,0.01,0.1,1,10,100) labels=paste0(\"lambda=\",lambda_spline_all) i=1 x=seq(0,3,length.out=2487) y=1 for(lambda in lambda_spline_all){   fit<-coxtp(event=event,z=data,time=time,lambda_spline = lambda)   plot<-coxtp.plot(fit,coef=\"V1\",ylab=\"HR(log-scale)\") +      theme(text = element_text(size = 10),           axis.text.x = element_text(size = 8),           axis.text.y=element_text(size = 8)) +      ggtitle(\"\")  +      geom_line(aes(x=x,y=y))   plot   assign(paste0(\"plot\",i),plot)   i=i+1 }  library(cowplot)  title <- ggdraw() +    draw_label(     paste0(\"Penalized NR,knot=\",8),     fontface = 'bold',     x = 0,     hjust = 0,     size=15   ) +   theme(     plot.margin = margin(0, 0, 0, 7)   ) p1=plot_grid(plot1,plot2,plot3,plot4,plot5,plot6,ncol=2,labels=labels,label_size = 13) p1"},{"path":"/articles/surtvep.html","id":"efficacy","dir":"Articles","previous_headings":"4. Model fitting > 6. Model performance > 6.1 Internal comparison","what":"6.1.2 Efficacy","title":"Introduction to surtvep","text":"Next, going compare Efficacy different methods. main function used eliminate computation time parallel. function, default setting parallel parallel=FALSE. parallel computation, also need define threads, refers number cores computer. set thread=4. following code plot use compare parallel non-parallel time different sample size:","code":"library(stringi) library(stringr) library(dplyr) samplesize_list=c(1000,2000,3000,4000,5000) i=1 for(samplesize in samplesize_list){   print(i)   sim_data_sub=sim_data[1:samplesize,]   event_sub=sim_data_sub[,\"event\"]   time_sub=sim_data_sub[,\"time\"]   data_sub=sim_data_sub[,!colnames(sim_data_sub) %in% c(\"event\",\"time\")]      non_parallel=bench::mark(coxtp(event=event_sub,z=data_sub,time=time_sub,lambda_spline = 100))[,1:8]   parallel=bench::mark(coxtp(event=event_sub,z=data_sub,time=time_sub,lambda_spline = 100,parallel = T,threads = 4))[,1:8]   non_parallel[,1]=samplesize   parallel[,1]=samplesize    if(i!=1){     non_parallel_list=rbind(non_parallel_list,non_parallel)     parallel_list=rbind(parallel_list,parallel)   } else {     non_parallel_list=non_parallel     parallel_list=parallel   }      i=i+1 } #> [1] 1 #> [1] 2 #> Warning: Some expressions had a GC in every iteration; so filtering is disabled. #> [1] 3 #> Warning: Some expressions had a GC in every iteration; so filtering is disabled. #> [1] 4 #> Warning: Some expressions had a GC in every iteration; so filtering is disabled.  #> Warning: Some expressions had a GC in every iteration; so filtering is disabled. #> [1] 5 #> Warning: Some expressions had a GC in every iteration; so filtering is disabled.  #> Warning: Some expressions had a GC in every iteration; so filtering is disabled.  parallel_list$parallel=\"Parallel\" non_parallel_list$parallel=\"None-Parallel\" time_data=rbind(parallel_list,non_parallel_list) %>%   mutate(median_time=str_remove(median,\"s\"),          median_time=str_remove(median_time,\"m\"),          median_time=as.numeric(median_time),          median_time=ifelse(str_detect(median,\"ms\"),median_time/1000,median_time)) %>%   rename(samplesize=expression)  #Plot Time used: ggplot(time_data,aes(x=samplesize,y=median_time,group=parallel)) +    geom_point(aes(color=parallel)) +    geom_line(aes(color=parallel)) +   labs(x=\"Sample Size\",y=\"Seconds\",title=\"Internal Computation time Comparison\")"},{"path":[]},{"path":"/articles/surtvep.html","id":"accurancy-1","dir":"Articles","previous_headings":"4. Model fitting > 6. Model performance > 6.2 External comparison","what":"6.2.1 Accurancy","title":"Introduction to surtvep","text":"section, going compare performance package time-varying survival packages.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Xueting Tao. Author, maintainer. Lingfeng Luo. Author. Wenbo Wu. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tao X, Luo L, Wu W (2022). surtvep: Cox Non-proportional Hazards model penalization. R package version 1.0.0, https://github.com/UM-KevinHe/surtvep.","code":"@Manual{,   title = {surtvep: Cox Non-proportional Hazards model with penalization},   author = {Xueting Tao and Lingfeng Luo and Wenbo Wu},   year = {2022},   note = {R package version 1.0.0},   url = {https://github.com/UM-KevinHe/surtvep}, }"},{"path":"/index.html","id":"surtvep","dir":"","previous_headings":"","what":"Cox Non-proportional Hazards model with penalization","title":"Cox Non-proportional Hazards model with penalization","text":"Cox Non-PH model penalization","code":""},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Cox Non-proportional Hazards model with penalization","text":"Large-scale time--event data derived national disease registries arise rapidly medical studies. Detecting accounting time-varying effects particularly important, time-varying effects already reported clinical literature. However, formal R packages estimating time-varying effect without pre-assuming time-dependent function. However, real dataset, get pre-assuming incorrect, estimation largely influenced assumption. Thus, decided develop time-varying model using spline terms penalization don’t need pre-assumption true time-dependent function implemented R. Following benefits packages: begin , traditional methods modeling time-varying survival models typically rely expanding original data repeated measurement format, , even moderate sample size, usually leads intractably large working dataset. Consequently, computational burden increases dramatically sample size grows, precluding evaluation time-varying effects large-scale studies, thus, propose computationally efficient Kronecker product-based proximal algorithm, enables us extend existing methods estimating time-varying effects time--event data large-scale context. Detailed information method found . Also, allowing parallel computing, packages handle moderate large sample size quite well compared current methods compare end page. Specifically, data analysis include number binary covariates near-zero variation (e.g., SEER prostate cancer data, 0.6% 716,553 patients tumors regional lymph nodes), associated observed information matrix Newton-type method may minimum eigenvalue close zero large condition number. Inverting nearly singular matrix numerically unstable corresponding Newton updates likely conned within small neighborhood initial value, causing estimates far optimal solutions. However, proposed Proximal-Newtown method handle problem quite well adding (describe edited Hessian matrix)","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Cox Non-proportional Hazards model with penalization","text":"","code":"#Install the package, need to install the devtools packages: install.packages(\"devtools\") devtools::install_github(\"UM-KevinHe/surtvep\")  #To install with Vignettes: install.packages(\"devtools\") devtools::install_github(\"UM-KevinHe/surtvep\",build_vignettes =T)"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage:","title":"Cox Non-proportional Hazards model with penalization","text":", using Simulation study included packages example","code":"library(surtvep)  #Load Simulation study sim_data=sim_data #Clean and create label and covariate matrix for the package: event=sim_data[,\"event\"] time=sim_data[,\"time\"] data=sim_data[,!colnames(sim_data) %in% c(\"event\",\"time\")]  #Fit the model(Time varying model without penalty)  fit <- coxtp(event = event, z = data, time = time) coxtp.plot(fit,coef=\"V1\")"},{"path":[]},{"path":"/index.html","id":"detailed-tutorial","dir":"","previous_headings":"","what":"Detailed tutorial","title":"Cox Non-proportional Hazards model with penalization","text":"detailed tutorial model paramter explaination, please go ","code":""},{"path":"/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help:","title":"Cox Non-proportional Hazards model with penalization","text":"encounter problems bugs, please contact : xuetao@umich.edu","code":""},{"path":"/reference/coxtp.baseline.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating Baseline hazard using the result from coxtp() — coxtp.baseline","title":"Calculating Baseline hazard using the result from coxtp() — coxtp.baseline","text":"Calculating Baseline hazard using result coxtp()","code":""},{"path":"/reference/coxtp.baseline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating Baseline hazard using the result from coxtp() — coxtp.baseline","text":"","code":"coxtp.baseline(fit, delta, z, time, strata = c())"},{"path":"/reference/coxtp.baseline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating Baseline hazard using the result from coxtp() — coxtp.baseline","text":"fit Model get coxtp delta event vector, vector containing 0 1 z Covariate matrix time Time vector, vector non-negative numeric value strata stratification group defined data. exist stratification group, please enter vector.","code":""},{"path":[]},{"path":"/reference/coxtp.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox Non-proportional Hazards model with penalization: Main function — coxtp","title":"Cox Non-proportional Hazards model with penalization: Main function — coxtp","text":"Cox Non-proportional Hazards model penalization: Main function","code":""},{"path":"/reference/coxtp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox Non-proportional Hazards model with penalization: Main function — coxtp","text":"","code":"coxtp(   event,   z,   time,   strata = c(),   spline = \"Smooth-spline\",   nsplines = 8,   ties = \"Breslow\",   tol = 1e-09,   iter.max = 20L,   method = \"Newton\",   lambda = 1e+08,   btr = \"static\",   tau = 0.5,   stop = \"ratch\",   parallel = FALSE,   threads = 1L,   degree = 3L,   TIC = FALSE,   TIC_prox = FALSE,   lambda_spline = 0,   ord = 4,   fixedstep = FALSE,   ICLastOnly = TRUE,   penalizestop = FALSE )"},{"path":"/reference/coxtp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox Non-proportional Hazards model with penalization: Main function — coxtp","text":"event event vector, vector containing 0 1 z Covariate matrix time Time vector, vector non-negative numeric value strata stratification group defined data. exist stratification group, please enter vector. spline spline term Penalized Newton's Method(Add section Number related paper). Default setting spline=\"Smooth-spline\" nsplines Number base functions B-splines, default 8. ties Ways deal ties, default ties=\"Breslow\": tol Convergence threshold. default threshold set tol=1e-6 iter.max Maximum Iteration number, default iter.max=20L method Selecting Method used, default method=\"Newton\" lambda Parameter Proximal Newton's Method. Default lambda=1e8 btr Backtracking line search approach, default btr=\"static\": tau (Alpha beta?) Newton's Method, Default tau=0.5. Used control step size. stop Stopping rule, default stop=\"ratch\": parallel Parallel computation, Default parallel=FALSE threads Parallel computation parameter(number cores)Default threads=1L degree Degree smoothing spline. Default setting degree=3L. TIC  TIC_prox calculating information criteria, might numerical issue(second order derivative, Hessian matrix approximate singular), thus proposed add small term diagonal. Default TIC_prox = FALSE lambda_spline Smoothing parameter lambda. Default lambda_spline = 0 refers Newton's Method without penalization. ord Specify derivative penalize. Default setting ord=4. fixedstep might times stopping criteria working, thus, number steps set manually. Default value fixedstep = FALSE, true, stop iter.max ICLastOnly calculate last information criteria TRUE. Default ICLastOnly=FALSE penalizestop","code":""},{"path":[]},{"path":"/reference/coxtp.plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting result from coxtp() function — coxtp.plot","title":"Plotting result from coxtp() function — coxtp.plot","text":"Plotting result coxtp() function","code":""},{"path":"/reference/coxtp.plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting result from coxtp() function — coxtp.plot","text":"","code":"coxtp.plot(   fit,   IC = \"AIC\",   coef,   xlab = \"Time\",   ylab = \"Hazard Ratio (log-scale)\" )"},{"path":"/reference/coxtp.plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting result from coxtp() function — coxtp.plot","text":"fit Model get coxtp IC Creteria selected plotting coef variable needed plotted","code":""},{"path":[]},{"path":"/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for surtvep with 5000 observations of 4 variables: — sim_data","title":"Example data for surtvep with 5000 observations of 4 variables: — sim_data","text":"Example data surtvep 5000 observations 4 variables:","code":""},{"path":"/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for surtvep with 5000 observations of 4 variables: — sim_data","text":"","code":"sim_data"},{"path":"/reference/sim_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for surtvep with 5000 observations of 4 variables: — sim_data","text":"data.frame V1 Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1 V2 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5*t) event Simulated event variable, Binary varible 0, 1 time Simulated time variable, Continous variable non-negative value","code":""},{"path":"/reference/sim_data_p5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for surtvep with 5000 observations of 7 variables: — sim_data_p5","title":"Example data for surtvep with 5000 observations of 7 variables: — sim_data_p5","text":"Example data surtvep 5000 observations 7 variables:","code":""},{"path":"/reference/sim_data_p5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for surtvep with 5000 observations of 7 variables: — sim_data_p5","text":"","code":"sim_data_p5"},{"path":"/reference/sim_data_p5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for surtvep with 5000 observations of 7 variables: — sim_data_p5","text":"data.frame 5000 observations 7 variables: V1 Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1 V2 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=sin(3pit/4) V3 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=-1 V4 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=(t/3)**2exp(t/2) V5Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5t) event Simulated event variable, Binary varible 0, 1 time Simulated time variable, Continous variable non-negative value","code":""},{"path":"/reference/sim_data_p5_f5.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for surtvep with 5000 observations of 8 variables(With strata): — sim_data_p5_f5","title":"Example data for surtvep with 5000 observations of 8 variables(With strata): — sim_data_p5_f5","text":"Example data surtvep 5000 observations 8 variables(strata):","code":""},{"path":"/reference/sim_data_p5_f5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for surtvep with 5000 observations of 8 variables(With strata): — sim_data_p5_f5","text":"","code":"sim_data_p5_f5"},{"path":"/reference/sim_data_p5_f5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for surtvep with 5000 observations of 8 variables(With strata): — sim_data_p5_f5","text":"data.frame V1 Simulated covariate V1, Binary variable 0, 1. True time-dependent function b(t)=1 V2 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=sin(3pit/4) V3 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=-1 V4 Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=(t/3)**2exp(t/2) V5Simulated covariate V2, Binary variable 0, 1. True time-dependent function b(t)=exp(-1.5t) event Simulated event variable, Binary varible 0, 1 time Simulated time variable, Continous variable non-negative value facility Simulated stratification variable. 5 levels","code":""}]
