<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>surtvep • surtvep</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="surtvep">
<meta property="og:description" content="surtvep">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-54921687-5"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-54921687-5');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">surtvep</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/surtvep.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Appendix
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Category A</li>
    <li>
      <a href="../articles/Appendix.html">B-spline construction</a>
    </li>
    <li>
      <a href="../articles/a2.html">Title A2</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Category B</li>
    <li>
      <a href="../articles/plotting.html">Plotting</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Appendix
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Category A</li>
    <li>
      <a href="../articles/Appendix.html">B-spline construction</a>
    </li>
    <li>
      <a href="../articles/a2.html">Title A2</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Category B</li>
    <li>
      <a href="../articles/plotting.html">Plotting</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Appendix2
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li class="dropdown-header">Category A</li>
    <li>
      <a href="../articles/Appendix.html">B-spline construction</a>
    </li>
    <li>
      <a href="../articles/a2.html">Title A2</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Category B</li>
    <li>
      <a href="../articles/plotting.html">Plotting</a>
    </li>
  </ul>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>surtvep</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/UM-KevinHe/surtvep/blob/HEAD/vignettes/surtvep.Rmd" class="external-link"><code>vignettes/surtvep.Rmd</code></a></small>
      <div class="hidden name"><code>surtvep.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction:<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p><code>surtvep</code> is an R package for fitting penalized Newton’s
method for the time-varying effects model using mAIC, TIC, GIC as
information criteria, in particular we span the parameter using basis
functions. Utilities for carrying out post-fitting visualization,
summarization, and inference are also provided. In this tutorial we
introduce the use of <code>surtvep</code> through an example
dataset.</p>
<p>This tutorial aims to provide a comprehensive guide on survival
estimation for the time-varying coefficient model using the
<code>surtvep</code> package in R. The package addresses the challenges
associated with large-scale time-to-event data and the estimation of
time-varying effects in survival analysis. By implementing a
computationally efficient Kronecker product-based proximal algorithm and
incorporating various penalties to improve estimation,
<code>surtvep</code> offers an efficient and flexible solution for
handling time-varying coefficients in survival analysis.</p>
<p>Throughout the tutorial, we will cover the key features and
capabilities of the <code>surtvep</code> package, providing examples and
use cases to illustrate the package’s functionality. By the end of this
tutorial, you will have a solid understanding of how to use
<code>surtvep</code> for survival estimation with time-varying
coefficients, as well as how to leverage the package’s unique features
to improve your analysis.</p>
</div>
<div class="section level2">
<h2 id="installation">Installation:<a class="anchor" aria-label="anchor" href="#installation"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#Install the package, need to install the devtools packages:</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="st"><a href="https://devtools.r-lib.org/" class="external-link">"devtools"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="st"><a href="https://remotes.r-lib.org" class="external-link">"remotes"</a></span><span class="op">)</span></span>
<span><span class="fu">remotes</span><span class="fu">::</span><span class="fu"><a href="https://remotes.r-lib.org/reference/install_github.html" class="external-link">install_github</a></span><span class="op">(</span><span class="st">"UM-KevinHe/surtvep"</span>, ref <span class="op">=</span> <span class="st">"Lingfeng_test"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="quick-start">Quick Start<a class="anchor" aria-label="anchor" href="#quick-start"></a>
</h2>
<p>The purpose of this section is to give users a general sense of the
package. We will briefly go over the main functions, basic operations
and outputs. After this section, users may have a better idea of what
functions are available, which ones to use, or at least where to seek
help.</p>
<p>First, we load the ‘surtvep’ package:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/UM-KevinHe/surtvep" class="external-link">"surtvep"</a></span><span class="op">)</span></span></code></pre></div>
<p>The main functions used in the package are Newton’s method ‘coxtv’
and Newton’s method combined with penalization ‘coxtp’, which we will
demonstrate in this section. We load a set of data created beforehand
for illustration:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleData"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">z</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>The command loads an input covariate matrix ‘z’, time-to-event
outcome ‘time’ and ‘event’ from this saved R data archive. The saved
data set is a simulation data set with continuous covariates.</p>
<p>We fit the Newton’s method without penalization use the most basic
call to ‘coxtv’.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.tv</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time <span class="op">=</span> <span class="va">time</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.2982771; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.2916285; Stopping crit = 2.1424865e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.2916034; Stopping crit = 8.0884492e-05;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.2916034; Stopping crit = 1.8232153e-09;</span></span>
<span><span class="co">#&gt; Algorithm converged after 4 iterations!</span></span></code></pre></div>
<p>‘fit.tv’ is an object of class ‘coxtv’ that contains all the relevant
information of the fitted model for further use. We do not encourage
users to extract the components directly. Instead, various methods are
provided for the object such as <code>plot</code> and <code>test</code>
that enable us to execute those tasks more elegantly.</p>
<p>We can get the time-varying coefficients by calling the
<code>get.tvcoef</code> method:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">beta.tv</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.tvcoef.html">get.tvcoef</a></span><span class="op">(</span><span class="va">fit.tv</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">beta.tv</span><span class="op">)</span></span>
<span><span class="co">#&gt;                             X1          X2</span></span>
<span><span class="co">#&gt; 0.000178354960296403 0.8190941 -0.07539314</span></span>
<span><span class="co">#&gt; 0.000355177544950556 0.8202944 -0.07436044</span></span>
<span><span class="co">#&gt; 0.000532422851851532 0.8214929 -0.07332691</span></span>
<span><span class="co">#&gt; 0.0011332947259668   0.8255221 -0.06983544</span></span>
<span><span class="co">#&gt; 0.00146478440156426  0.8277227 -0.06791732</span></span>
<span><span class="co">#&gt; 0.00224849921081871  0.8328625 -0.06340520</span></span></code></pre></div>
<p>The first row of <code>beta.tv</code> represents the time-varying
coefficient of x1 and x2 at time 0.00017835.</p>
<p>In order to get the time-varying coefficients on a new time sequence,
we can modify the <code>times</code> argument in
<code>get.tvcoef</code>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">time.new</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="va">beta.tv.new</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.tvcoef.html">get.tvcoef</a></span><span class="op">(</span><span class="va">fit.tv</span>, time <span class="op">=</span> <span class="va">time.new</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">beta.tv.new</span><span class="op">)</span></span>
<span><span class="co">#&gt;            X1         X2</span></span>
<span><span class="co">#&gt; 1   1.0753701  0.7029324</span></span>
<span><span class="co">#&gt; 1.1 1.0529174  0.5242153</span></span>
<span><span class="co">#&gt; 1.2 1.0039703  0.3215421</span></span>
<span><span class="co">#&gt; 1.3 0.9365847  0.1039432</span></span>
<span><span class="co">#&gt; 1.4 0.8590977 -0.1195252</span></span>
<span><span class="co">#&gt; 1.5 0.7798461 -0.3398073</span></span></code></pre></div>
<p>We can visualize the time-varying coefficients by executing the
<code>plot</code> method:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.tv</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-8-1.png" width="672"></p>
<p>Each sub figure corresponds to a variable. It shows the time-varying
effect of our predictors. In our <code>ExampleData</code>, the first
predictor has a constant effect of 1, and the second predictor has a
time-varying effect of <span class="math inline">\(\text{sin}(3\pi *
t/4)\)</span>, where <span class="math inline">\(t\)</span> is the time.
The dotted line indicates the that hazard ratio is 0, which means the
predictor has no effect. Users may also wish to plot the effect of
different covariates in the same plot: this can be done by setting
<code>allinone = TRUE</code> in the plot command.</p>
<p>The confidence interval shown presented on the figure can be
calculated using the <code>confint</code> function.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ci.df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/confint.html" class="external-link">confint</a></span><span class="op">(</span><span class="va">fit.tv</span><span class="op">)</span></span></code></pre></div>
<p>Note that users can draw the plots by yourself with the necessary
data given. We give some raw example <code>ggplot</code> codes. Please
refer to <a href="#plotting-section">plotting</a> for more
information.</p>
<p>Next we fit the Newton’s method combined with penalization method. We
specify a range of penalization coefficients first, then call the
<code>coxtp</code> function. Detailed disucussion of how to specify the
range of penalization coefficients and how to choose the appropriate one
will be discussed in section Information Criteria.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_all</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">fit.penalize</span> <span class="op">=</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, lambda <span class="op">=</span> <span class="va">lambda_all</span>, method <span class="op">=</span> <span class="st">"ProxN"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "start fitting:"</span></span>
<span><span class="co">#&gt; [1] 10</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="co">#&gt; [1] 2</span></span>
<span><span class="co">#&gt; [1] 20</span></span>
<span><span class="co">#&gt; [1] 1e-06</span></span>
<span><span class="co">#&gt; [1] 0.01</span></span>
<span><span class="co">#&gt; NULL</span></span>
<span><span class="co">#&gt; [1] "dynamic"</span></span>
<span><span class="co">#&gt; [1] "ratch"</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="co">#&gt; NULL</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3017443; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.2954100; Stopping crit = 2.0664261e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.2953323; Stopping crit = 2.5346890e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.2953321; Stopping crit = 4.6097119e-07;</span></span>
<span><span class="co">#&gt; Algorithm converged after 4 iterations!</span></span>
<span><span class="co">#&gt; lambda 1 is done.</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.penalize</span><span class="op">$</span><span class="va">lambda1</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-11-1.png" width="672"></p>
<p>With the tools introduced so far, users are able to fit the
time-varying model. There are many more arguments in the package that
give users a great deal of flexibility. To learn more, move on to later
section.</p>
</div>
<div class="section level2">
<h2 id="structure">Structure<a class="anchor" aria-label="anchor" href="#structure"></a>
</h2>
<p>This section gives the flowchart for the <code>surtvep</code>
package. Generally, <code>coxtv</code> utilizes proximal Newton’s method
to estimate the time-varying coefficients. <code>coxtp</code> combines
the Newton’s approach with penalization. <code>IC</code> calculates
different information criteria to select the best tuning parameter in
front of the penalty term. <code>cv.coxtp</code> uses cross-validation
for tuning parameter selection.. <code>tvef.ph</code>,
<code>tvef.ph.time</code> and <code>tvef.ph.zero</code> provides
hypothesis testing for the fitted model. <code>get.tvef</code> retrieves
the time-varying coefficients for the fitted model. <code>confint</code>
provides confidence intervals for these coefficients.
<code>baseline</code> offers the baseline estimations. <code>plot</code>
visualizes the estimated time-varying coefficients. Other functions and
details are provided in later sections.</p>
<div class="float">
<img src="../../../../../Dropbox%20(University%20of%20Michigan)/Lingfeng%20Research/R%20Tutorial%20Package/surtvep/articles/hr_appendix_stage_joss.png" alt="Alt"><div class="figcaption">Alt</div>
</div>
</div>
<div class="section level2">
<h2 id="cox-non-proportional-hazards-model">Cox non-proportional hazards model<a class="anchor" aria-label="anchor" href="#cox-non-proportional-hazards-model"></a>
</h2>
<p>While obtaining these estimates under the Cox proportional-hazards
model is relatively straightforward, the assumption of constant hazard
ratios is frequently violated in populations defined by an initial,
acute event, such as myocardial infarction, or in studies with long-term
follow-up.</p>
<p>The Cox non-proportional hazards model is a flexible and powerful
tool for modeling the time-varying effects of covariates in survival
analysis, allowing for the estimation of hazard ratios that change over
time. This model can capture complex relationships between predictor
variables and the time-to-event outcome, providing a more accurate
representation of the underlying processes.</p>
<p>Let <span class="math inline">\(D_{i}\)</span> denote the time lag
from transplantation to death and <span class="math inline">\(C_{i}\)</span> be the censoring time for patient
<span class="math inline">\(i\)</span>, <span class="math inline">\(i=1,\ldots, n\)</span>. Here <span class="math inline">\(n_j\)</span> is the sample size. The observed time
is <span class="math inline">\(T_{i} = \min\{D_{i},C_{i}\}\)</span>, and
the death indicator is given by <span class="math inline">\(\delta_{i} =
I(D_{i} \leq C_{i})\)</span>. Let <span class="math inline">\(\boldsymbol{X}_{i}=(X_{i1}, \ldots,
X_{iP})^T\)</span> be a <span class="math inline">\(P\)</span>-dimensional covariate vector. We assume
that <span class="math inline">\(D_{i}\)</span> is independent from
<span class="math inline">\(C_{i}\)</span> given <span class="math inline">\(\textbf{X}_{i}\)</span>. Consider the hazard
function <span class="math display">\[
   \lambda(t|\boldsymbol{X}_{i}) =
\lambda_{0}(t)\exp\{\boldsymbol{X}_{i}^\top{\boldsymbol\beta}(t)\},
%\nonumber
\]</span> where <span class="math inline">\(\lambda_{0}(t)\)</span> is
the baseline hazard. The time-varying coefficients <span class="math inline">\(\beta(t)\)</span> represent the effect of
predictors on the outcome are varying through different time points.</p>
<p>To estimate the time-varying coefficients <span class="math inline">\({\boldsymbol\beta}(t)=\{\beta_{1}(t),\ldots,
\beta_{P}(t)\}\)</span>, we span <span class="math inline">\(\boldsymbol\beta(\cdot)\)</span> by a set of cubic
B-splines defined on a given number of knots: <span class="math display">\[\begin{eqnarray}
   \beta_{p}(t)=\boldsymbol\theta_{p}^\top\boldsymbol{B}(t)=\sum_{k=1}^K
\theta_{pk} B_k(t), ~~ p=1, \ldots, P,   \nonumber
\end{eqnarray}\]</span> where <span class="math inline">\(\boldsymbol{B}
(t)=\{B_1(t), \ldots, B_K(t)\}^T\)</span> forms a basis, <span class="math inline">\(K\)</span> is the number of basis functions, and
<span class="math inline">\(\boldsymbol\theta_{p}=(\theta_{p1}, \ldots,
\theta_{pK})^T\)</span> is a vector of coefficients with <span class="math inline">\(\theta_{pk}\)</span> being the coefficient for the
<span class="math inline">\(k\)</span>-th basis of the <span class="math inline">\(p\)</span>-th covariate. Detailed inforamtion
about the construction of the B-spline basis can seen in the <a href="Appendix.html">B-spline construction</a>.</p>
</div>
<div class="section level2">
<h2 id="newtons-method">Newton’s method<a class="anchor" aria-label="anchor" href="#newtons-method"></a>
</h2>
<p>In this section we introduce the Newton’s method for estimating
time-varying effects in detail.</p>
<p>With a length-<span class="math inline">\(PK\)</span> parameter
vector <span class="math inline">\(\boldsymbol\theta=vec(\boldsymbol\Theta)\)</span>,
the vectorization of the coefficient matrix <span class="math inline">\(\boldsymbol\Theta=(\boldsymbol\theta_{1}, \ldots,
\boldsymbol\theta_{P})^T\)</span> by row, the log-partial likelihood
function is <span class="math display">\[\begin{equation}
  \ell(\boldsymbol\theta)=\sum_{i=1}^{n_j} \delta_{i} \left
[\boldsymbol{X}_{i}^T \boldsymbol\Theta  \boldsymbol{B}(T_{i})
  -\log
  \left\{\sum_{i' \in R_{i}}  \exp \{\boldsymbol{X}_{i' }^T
\boldsymbol\Theta  \boldsymbol{B}(T_{i}) \} \right \} \right ]
\end{equation}\]</span>, where <span class="math inline">\(R_{i}=\{i': 1 \leq i' \leq n, ~
T_{i'}\geq T_{i}\}\)</span> is the at-risk set.</p>
<p><code>coxtv</code> applies Newton’s method to solve the problem.
Specifically, suppose we have current estimates <span class="math inline">\(\widetilde{\boldsymbol\theta}\)</span>, the update
is <span class="math display">\[
    \widetilde{\boldsymbol\theta} \leftarrow
\widetilde{\boldsymbol\theta} + \nu \boldsymbol{\mu};
\]</span> where <span class="math display">\[
  \boldsymbol{\mu} = \left(- \nabla^2 \ell(\boldsymbol{\theta})
\right)^{-1} \nabla \ell(\boldsymbol{\theta})
\]</span>, and <span class="math inline">\(\nu\)</span> is a step size
adjusted by backtracking linesearch. <span class="math inline">\(\nabla
\ell(\boldsymbol{\theta})\)</span> and <span class="math inline">\(\nabla^2 \ell(\boldsymbol{\theta})\)</span> is the
first and second derivative of the log partial likelihood.</p>
<div class="section level3">
<h3 id="commonly-used-function-arguments">Commonly used function arguments<a class="anchor" aria-label="anchor" href="#commonly-used-function-arguments"></a>
</h3>
<p><code>coxtv</code> provides various arguments for users to customize
the fit: we introduce some commonly used arguments here.</p>
<ul>
<li><p><code>strata</code> is a vector of indicators for stratification.
Default = <code>NULL</code>, (i.e. no stratification group in the data),
an unstratified model is implemented.</p></li>
<li><p><code>nsplines</code> number of basis functions in the splines to
span the time-varying effects, whose default value is 8. We use the R
function <code><a href="https://rdrr.io/r/splines/bs.html" class="external-link">splines::bs</a></code> to generate the B-splines.</p></li>
<li><p><code>ties</code> a character string specifying the method for
tie handling. If there are no tied events, the methods are equivalent.
By default <code>"Breslow"</code> uses the Breslow approximation, which
can be faster when many ties are present.</p></li>
<li><p><code>tol</code> tolerance used for stopping the algorithm. See
details in <code>stop</code> below. The default value is
<code>1e-6</code>.</p></li>
<li><p><code>iter.max</code> maximum iteration number if the stopping
criterion specified by <code>stop</code> is not satisfied. Default value
is 20.</p></li>
<li><p><code>degree</code> degree of the piecewise polynomial for
generating the B-spline basis functions—default is 3 for cubic splines.
<code>degree = 2</code> results in the quadratic B-spline basis
functions.</p></li>
<li><p><code>method</code> a character string specifying whether to use
Newton method or proximal Newton method. If <code>"Newton"</code> then
Hessian is used, while the default method <code>"ProxN"</code>
implements the proximal Newton which can be faster and more stable when
there exists ill-conditioned second-order information of the log-partial
likelihood.</p></li>
<li><p><code>gammma</code> parameter for proximal Newton method
<code>"ProxN"</code>. Default value is <code>1e8</code>.</p></li>
<li><p><code>btr</code> a character string specifying the backtracking
line-search approach. <code>"dynamic"</code> is a typical way to perform
backtracking line-search. See details in Convex Optimization by Boyd and
Vandenberghe (2009). <code>"static"</code> limits Newton’s increment and
can achieve more stable results in some extreme cases, such as
ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low
frequency for some categories. Users should be careful with
<code>static</code> as this may lead to under-fitting.</p></li>
<li><p><code>tau</code> a scalar in (0,1) used to control the step size
inside the backtracking line-search. The default value is 0.5.</p></li>
<li><p><code>stop</code> character string specifying the stopping rule
to determine convergence. Use to denote the log-partial likelihood at
iteration step m.<br><code>"incre"</code> means we stop the algorithm when Newton’s increment
is less than the <code>tol</code>. <code>"relch"</code> means we stop
the algorithm when the is less than the <code>tol</code>.
<code>"ratch"</code> means we stop the algorithm when is less than the
<code>tol</code>. <code>"all"</code> means we stop the algorithm when
all the stopping rules <code>"incre"</code>, <code>"relch"</code> and
<code>"ratch"</code> are met. Default value is
<code>ratch</code>.</p></li>
<li><p><code>iter.max</code>, if achieved, overrides any stop rule for
algorithm termination.</p></li>
<li><p><code>parallel</code> if <code>TRUE</code>, then the parallel
computation is enabled. The number of threads in use is determined by
<code>threads</code>.</p></li>
<li><p><code>threads</code> an integer indicating the number of threads
to be used for parallel computation. Default is <code>2</code>. If
<code>parallel</code> is false, then the value of <code>threads</code>
has no effect.</p></li>
<li><p><code>fixedstep</code> if <code>TRUE</code>, the algorithm will
be forced to run <code>iter.max</code> steps regardless of the stopping
criterion specified.</p></li>
</ul>
<p>In the following sections we brefily describe these useful arguments
when calling <code>coxtv</code>.</p>
<p>Now we start with a relatively harsh simulated data. Here, the
covariates V1 and V2 were generated as binary variables with around 90%
frequency, which is a relatively harsh setting to be estimated. The
related true log-hazard function for each variable is <span class="math inline">\(\beta_1(t)=1\)</span> and <span class="math inline">\(\beta_2(t)=exp(-1.5*t)\)</span>, where t denotes
time.</p>
<p>Let’s check the data first:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleDataBinary"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt; table of extent 0 &gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; &lt; table of extent 0 &gt;</span></span>
<span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">z</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>Both predictors are presented with frequency around 25%.</p>
</div>
<div class="section level3">
<h3 id="proximal-newtons-method-method-proxn">Proximal Newton’s method: <code>method = "ProxN"</code><a class="anchor" aria-label="anchor" href="#proximal-newtons-method-method-proxn"></a>
</h3>
<p>The ‘method’ parameter has two options.
<em><code>method="Newton"</code></em> and
<em><code>method="ProxN"</code></em>. The proximal Newton’s method
modified the second order derivative <span class="math inline">\(\nabla^2 \ell(\boldsymbol{\theta})\)</span> by
adding small terms <span class="math inline">\(1/\gamma\)</span> to the
the diagonal elements. The default value of <span class="math inline">\(\gamma\)</span> is <span class="math inline">\(10^8\)</span>, which can be modified by user. If
the data set have predictors with extremely low frequency, users may
consider a smaller <span class="math inline">\(\gamma\)</span>.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.newton</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time <span class="op">=</span> <span class="va">time</span>, method <span class="op">=</span> <span class="st">'Newton'</span><span class="op">)</span></span>
<span><span class="va">fit.proxN</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time <span class="op">=</span> <span class="va">time</span>, method <span class="op">=</span> <span class="st">'ProxN'</span><span class="op">)</span></span></code></pre></div>
<p>Then we plot the fitted methods with all the curves on the same plot.
No obvious change can be oberserved here. However, we do recommand
using</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.newton</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, allinone <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.proxN</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, allinone <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-14-1.png" width="40%" height="44%"><img src="surtvep_files/figure-html/unnamed-chunk-14-2.png" width="40%" height="44%"></p>
</div>
<div class="section level3">
<h3 id="stratified-newtons-method-strata">Stratified Newton’s Method: <code>strata</code><a class="anchor" aria-label="anchor" href="#stratified-newtons-method-strata"></a>
</h3>
<p>When the data of patients are collected from different strata, we can
extend the model to a stratified version. We use <span class="math inline">\(j=1,\ldots,J\)</span> to denote the <span class="math inline">\(J\)</span> different centers. Let <span class="math inline">\(D_{ij}\)</span> denote the time to death and <span class="math inline">\(C_{ij}\)</span> be the censoring time for patient
<span class="math inline">\(i\)</span> in center <span class="math inline">\(j\)</span>, <span class="math inline">\(i=1,\ldots, n_j\)</span>, and <span class="math inline">\(j=1, \ldots, J\)</span>. Here <span class="math inline">\(n_j\)</span> is the sample size in center <span class="math inline">\(j\)</span>. The total number of patients is <span class="math inline">\(N=\sum_{j=1}^Jn_j\)</span>, the observed time is
<span class="math inline">\(T_{ij} = \min\{D_{ij},C_{ij}\}\)</span>, and
the death indicator is given by <span class="math inline">\(\delta_{ij}
= I(D_{ij} \leq C_{ij})\)</span>.</p>
<p>Let <span class="math inline">\(\textbf{X}_{ij}=(X_{ij1}, \ldots,
X_{ijP})^T\)</span> be a <span class="math inline">\(P\)</span>-dimensional covariate vector. We assume
that <span class="math inline">\(D_{ij}\)</span> is independent from
<span class="math inline">\(C_{ij}\)</span> given <span class="math inline">\(\textbf{X}_{ij}\)</span>. Correspondingly, the
log-partial likelihood function is <span class="math display">\[
    \ell_{strata}(\boldsymbol\theta) = \sum_{j=1}^J \sum_{i=1}^{n_j}
\delta_{ij} \left [\boldsymbol{X}_{ij}^T
\boldsymbol\Theta  \boldsymbol{B}(T_{ij})
    -\log
    \left\{\sum_{i' \in R_{ij}}  \exp \{\boldsymbol{X}_{i' j}^T
\boldsymbol\Theta  \boldsymbol{B}(T_{ij}) \} \right \} \right ],
\]</span> where <span class="math inline">\(R_{ij}=\{i': 1 \leq
i' \leq n_j, ~ T_{i' j}\geq T_{ij}\}\)</span> is the at-risk set
for stratum <span class="math inline">\(j\)</span>.</p>
<p>For the case with different strata, the usage is to include the
strata variable. First, we load a set of generated data with different
stratums. In our simulation, we vary the baseline for different stratums
by adding a small term to the baseline function. The small term is
generated by uniform distribution with mean = 0 and standard deviation =
0.5.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"StrataExample"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">z</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">event</span></span>
<span><span class="va">strata</span> <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">strata</span></span></code></pre></div>
<p>The <code>strata</code> is a vector of indicators for stratification.
The stratified model can be easily fitted by calling</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.strata</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, strata <span class="op">=</span> <span class="va">strata</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.strata</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
</div>
<div class="section level3">
<h3 id="step-size-adjustment-btr">Step size adjustment: <code>btr</code><a class="anchor" aria-label="anchor" href="#step-size-adjustment-btr"></a>
</h3>
<p><code>btr</code> is a character string specifying the backtracking
line-search approach. <code>"dynamic"</code> is a typical way to perform
backtracking line-search. See details in Convex Optimization by Boyd and
Vandenberghe (2009). <code>"static"</code> limits Newton’s increment and
can achieve more stable results in some extreme cases, such as
ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low
frequency for some categories.</p>
<p>Users should be careful with <code>static</code> as this may lead to
under-fitting.</p>
</div>
</div>
<div class="section level2">
<h2 id="newtons-method-with-penalization">Newton’s Method with penalization:<a class="anchor" aria-label="anchor" href="#newtons-method-with-penalization"></a>
</h2>
<p>The proximal Newton can help improve the estimation when the
origional hessian matrix is very close to a singular one, which may
often occur in the setting of time-varying effects, however,
over-fitting issue still exists. We further improve the estimation by
introducing the penalty. The basic idea of penalization is to control
the model’s smoothness by adding a ‘wiggliness’ penalty to the fitting
objective. Rather than fitting the non-proportional hazards model by
maximizing original log-partial likelihood, it could be fitted by
maximizing <span class="math display">\[\begin{align}
    \ell(\boldsymbol{\theta}) - P_\lambda(\boldsymbol{\theta}).
\end{align}\]</span></p>
<p>We have different choices of <span class="math inline">\(P_\lambda(\boldsymbol{\theta})\)</span>. Potential
choices are to use P-splines, and discrete penalties. Detailed
discussions are provided below.</p>
<div class="section level3">
<h3 id="p-spline">P-spline<a class="anchor" aria-label="anchor" href="#p-spline"></a>
</h3>
<p>The P-splines are low rank smoothers using a B-spline basis, usually
defined on evenly spaced knots, with a difference penalty applied
directly to the parameters <span class="math inline">\(\theta_{pk}\)</span>, to control function
wiggliness. When we set standard cubic B-spline basis functions, the
penalty function used for <span class="math inline">\(\beta_p\)</span>
will be <span class="math display">\[\begin{align*}
    P_\lambda(\boldsymbol{\theta}) =
\lambda\sum_{j=1}^P\sum_{k=1}^{K-1}\{(\boldsymbol{\theta}_{j(k+1)}  -
\boldsymbol{\theta}_{jk})\}^2.
\end{align*}\]</span></p>
<p>It is straight forward to express the penalty as a quadratic form,
<span class="math inline">\(\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}\)</span>,
in this basis coefficients:</p>
<span class="math display">\[\begin{align*}
    \sum_{k=1}^{K-1}\{(\boldsymbol{\theta}_{j(k+1)}  -
\boldsymbol{\theta}_{jk})\}^2
    =
        \boldsymbol{\theta}^T
    \begin{bmatrix}
        1 &amp; -1 &amp; 0 &amp; 0 &amp; . &amp; . &amp; . \\
        -1 &amp; 2  &amp; -1 &amp; 0 &amp; 0 &amp; . &amp; . \\
        0 &amp; -1  &amp; 2 &amp; -1 &amp; 0 &amp; 0 &amp; . \\
        . &amp; . &amp; . &amp; . &amp; . &amp; . &amp; .\\
        . &amp; . &amp; . &amp; . &amp; . &amp; . &amp; .\\
    \end{bmatrix}
    \boldsymbol{\theta}
\end{align*}\]</span>
<p>Hence the penalized fitting problem is to maximize <span class="math display">\[\begin{align}
    \ell(\boldsymbol{\theta}) -
\lambda\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}
\end{align}\]</span> with respect to <span class="math inline">\(\boldsymbol{\theta}\)</span>.</p>
</div>
<div class="section level3">
<h3 id="smoothing-spline">Smoothing-spline<a class="anchor" aria-label="anchor" href="#smoothing-spline"></a>
</h3>
<p>The reduced rank spline smoothers with derivative based penalties can
be set up almost as easily, while retaining the sparsity of the basis
and penalty and the ability to mix-and-match the orders of spline basis
functions and penalties.</p>
<p>We denote the B-spline basis as of order <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_1
= 3\)</span> denotes a cubic spline. Associated with the spline will be
a derivative based penalty <span class="math display">\[\begin{align*}
    P_{\lambda} = \lambda \int_{0}^{T}\boldsymbol{\beta}^{[m_2]}(t)^2dt
\end{align*}\]</span> where <span class="math inline">\(\boldsymbol{\beta}^{[m_2]}(t)\)</span> denotes the
<span class="math inline">\(m_2^{th}\)</span> derivative of <span class="math inline">\(\boldsymbol{\beta}\)</span> with respect to <span class="math inline">\(t\)</span>. It is assumed that <span class="math inline">\(m_2 \leq m_1\)</span>, otherwise it makes no sense
that the penalty is formulated in terms of a derivative that is not
properly defined for the basis functions. Similarly, <span class="math inline">\(P_{\lambda}\)</span> can be written as <span class="math inline">\(\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}\)</span>
where <span class="math inline">\(\boldsymbol{S}\)</span> is a banded
diagonal matrix of known coefficients. The algebraic expression of <span class="math inline">\(\boldsymbol{S}\)</span> is complex, as discussed
in . However, this has little impact on the computation time.</p>
</div>
<div class="section level3">
<h3 id="usage">Usage<a class="anchor" aria-label="anchor" href="#usage"></a>
</h3>
<p>The usage of Newton’s method with penalization <code>coxtp</code> is
very similar to <code>coxtv</code> introduced above. The main difference
comes from the penalization tuning parameter selection.</p>
<p>We use the smooth spline here for penalization (default). You could
also use <code>spline="P-spline"</code>. For tuning parameter
<code>lambda</code>, you could either enter a single numeric value or a
vector of numbers. If <code>lambda</code> is entered as a vector of
numbers, the tuning parameter can be selected based on different
criteria (AIC, TIC or GIC) using function <code>IC</code>.
Alternatively, users can use <code>cv.coxtp</code> to select the tuning
parameter <span class="math inline">\(\lambda\)</span> based on cross
validation.</p>
<p>Following is a model fit with the <code>lambda</code> as a vector for
different illustration purposes. We use the relatively harsh setting
<code>ExampleDataBinary</code> to illustrate the usage of
<code>coxtp</code>, <code>IC</code> and <code>cv.coxtp</code>, the
penalization method. This setting contains binary predictors with low
frequency, which may have ill-conditioned second-order information of
the log-partial likelihood. Penalization plays an important role here as
it helps to smooth the time-varying effects.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">z</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>First we fit the penalized model with
<code>"Smooth-spline"</code>.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_spline_all</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.01</span>,<span class="fl">0.1</span>,<span class="fl">1</span>,<span class="fl">10</span>,<span class="fl">100</span>,<span class="fl">1000</span><span class="op">)</span></span>
<span><span class="co"># fit.pspline &lt;- coxtp(event = event, z = z, time = time, lambda=lambda_spline_all, spline = "P-spline")</span></span>
<span><span class="va">fit.smoothspline</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">event</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time</span>, lambda <span class="op">=</span> <span class="va">lambda_spline_all</span>, penalty <span class="op">=</span> <span class="st">"Smooth-spline"</span><span class="op">)</span></span></code></pre></div>
<p>Then we use the <code>IC</code> function to select the tuning
parameter.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">IC</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/IC.html">IC</a></span><span class="op">(</span><span class="va">fit.smoothspline</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">mAIC</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 15209.79 15205.84 15201.74 15199.47 15199.18 15199.35</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">TIC</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 15207.09 15203.63 15199.85 15197.89 15198.62 15199.44</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">GIC</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 15208.92 15205.59 15201.99 15200.02 15199.50 15199.56</span></span></code></pre></div>
<p>We can directly call the <code>plot</code> function to give the
estimation plot.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">model.TIC</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-20-1.png" width="40%" height="44%"></p>
<p>From the result above, we notice that with different selection
criteria, the best tuning parameter <span class="math inline">\(\lambda\)</span> selected is different for
different selection criteria. In this example, we use the TIC criterion.
The result for this model is saved in the related criterion model and
can be accessed as follows:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">model.mAIC</span> <span class="op">=</span> <span class="va">IC</span><span class="op">$</span><span class="va">model.mAIC</span></span>
<span><span class="va">model.TIC</span> <span class="op">=</span> <span class="va">IC</span><span class="op">$</span><span class="va">model.TIC</span></span>
<span><span class="va">model.GIC</span> <span class="op">=</span> <span class="va">IC</span><span class="op">$</span><span class="va">model.GIC</span></span></code></pre></div>
<p>Compared to the non-penalized model, we can see that the effect of
``V1” is shrunk to approximately linear in the penalized model.</p>
</div>
</div>
<div class="section level2">
<h2 id="baseline-estimation">Baseline estimation<a class="anchor" aria-label="anchor" href="#baseline-estimation"></a>
</h2>
<p>The Nelson-Aalen estimator (Breslow estimator) of the cumulative
function is given by <span class="math inline">\(\widetilde{\Lambda}(t)
= \int_0^t \widetilde{\Lambda}_0(u)\)</span>, where <span class="math inline">\(\widetilde{\Lambda}(t)\)</span> is 0 except at the
observed failure times <span class="math inline">\(t_i\)</span>, at
which it takes the value <span class="math display">\[\begin{align*}
    d\Lambda_0 = {d_i}\left\{\mathop{\sum}\limits_{\ell \in R(T_i)} \exp
\{\boldsymbol{X}_{i' }^T \boldsymbol{\Theta}  \boldsymbol{B}(T_{i})
\}\right\}^{-1}.
\end{align*}\]</span></p>
<p>The baseline estimation here refers to the baseline hazard at time t
when holding all the covariates equal to zero.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleData"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">z</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">event</span></span>
<span><span class="va">time2</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">time</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_spline_all</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">1</span>,<span class="fl">10</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">fit.smoothspline</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">event</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time2</span>, lambda<span class="op">=</span><span class="va">lambda_spline_all</span>, penalty <span class="op">=</span> <span class="st">"Smooth-spline"</span><span class="op">)</span></span>
<span><span class="va">IC</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/IC.html">IC</a></span><span class="op">(</span><span class="va">fit.smoothspline</span><span class="op">)</span></span>
<span><span class="va">fit.mAIC</span> <span class="op">&lt;-</span> <span class="va">IC</span><span class="op">$</span><span class="va">model.mAIC</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base.est</span> <span class="op">=</span> <span class="fu"><a href="../reference/baseline.html">baseline</a></span><span class="op">(</span><span class="va">fit.mAIC</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">base.est</span><span class="op">)</span></span>
<span><span class="co">#&gt; $time</span></span>
<span><span class="co">#&gt;  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8</span></span>
<span><span class="co">#&gt; [20] 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $hazard</span></span>
<span><span class="co">#&gt;  [1] 0.02576925 0.04632723 0.04796684 0.05258371 0.04708783 0.04544031</span></span>
<span><span class="co">#&gt;  [7] 0.05096521 0.03807625 0.04421912 0.05162255 0.05153851 0.06367847</span></span>
<span><span class="co">#&gt; [13] 0.04167940 0.04678650 0.04840596 0.06907205 0.05280167 0.04285638</span></span>
<span><span class="co">#&gt; [19] 0.02951995 0.02536585 0.02495845 0.02703002 0.03259201 0.03841546</span></span>
<span><span class="co">#&gt; [25] 0.01788728 0.02645356 0.02097025 0.00000000 0.03385874 0.00000000</span></span>
<span><span class="co">#&gt; [31] 0.00000000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $cumulHaz</span></span>
<span><span class="co">#&gt;  [1] 0.02576925 0.07209648 0.12006331 0.17264703 0.21973486 0.26517517</span></span>
<span><span class="co">#&gt;  [7] 0.31614038 0.35421663 0.39843575 0.45005830 0.50159681 0.56527528</span></span>
<span><span class="co">#&gt; [13] 0.60695468 0.65374117 0.70214714 0.77121918 0.82402086 0.86687724</span></span>
<span><span class="co">#&gt; [19] 0.89639719 0.92176304 0.94672149 0.97375150 1.00634352 1.04475898</span></span>
<span><span class="co">#&gt; [25] 1.06264625 1.08909982 1.11007006 1.11007006 1.14392881 1.14392881</span></span>
<span><span class="co">#&gt; [31] 1.14392881</span></span></code></pre></div>
<p>As a result, we could either increase the time interval to make ties
exists or remove the points that have <span class="math inline">\(\lambda=0\)</span>. The only differences would
result in the baseline hazard, there is no influence on the cumulative
baseline hazard.</p>
</div>
<div class="section level2">
<h2 id="hypothesis-tests-for-the-model">Hypothesis Tests for the model<a class="anchor" aria-label="anchor" href="#hypothesis-tests-for-the-model"></a>
</h2>
<p>In this section we provide three tests for the model. The first is to
test</p>
<div class="section level3">
<h3 id="testing-for-time-varying-effect">Testing for time-varying effect<a class="anchor" aria-label="anchor" href="#testing-for-time-varying-effect"></a>
</h3>
<p>To test whether the effects are time-varying, we use the constant
property of B-splines, that is, if <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK},\)</span> the
corresponding covariate effect is time-independent. Specify a matrix
<span class="math inline">\(\boldsymbol{C}_p\)</span> such that <span class="math inline">\(\boldsymbol{C}_p\boldsymbol\theta=\textbf{0}\)</span>
corresponds to the contrast that <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK}\)</span>. A Wald
statistic can be constructed by <span class="math display">\[\begin{align*}
S_p=(\boldsymbol{C}_p\boldsymbol{\widehat\theta})^T
\left[\boldsymbol{C}_p \{- \triangledown^2
\ell(\boldsymbol{\widehat\theta})\}^{-1}\boldsymbol{C}_p^T\right]^{-1}(\boldsymbol{C}_p\boldsymbol{\widehat\theta}).
\end{align*}\]</span></p>
<p>Under the null hypothesis that the effect is time-independent, <span class="math inline">\(S_p\)</span> is asymptotically chi-square
distributed with <span class="math inline">\(K-1\)</span> degrees of
freedom.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tvef.ph.html">tvef.ph</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span>
<span><span class="co">#&gt;        chisq df          p</span></span>
<span><span class="co">#&gt; X1  6.889955  7 0.44042707</span></span>
<span><span class="co">#&gt; X2 21.437089  7 0.00317433</span></span></code></pre></div>
<p>For the second variable, We reject the null hypothesis and claim it
has the time varying effect.</p>
</div>
<div class="section level3">
<h3 id="testing-for-beta-effect">Testing for beta effect<a class="anchor" aria-label="anchor" href="#testing-for-beta-effect"></a>
</h3>
<p>To test whether the effects are significant or not, we use the test
statistic <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK} =
0,\)</span> the corresponding covariate effect is time-independent.
Specify a matrix <span class="math inline">\(\boldsymbol{C}_p\)</span>
such that <span class="math inline">\(\boldsymbol{C}_p\boldsymbol\theta=\textbf{0}\)</span>
corresponds to the contrast that <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK} = 0\)</span>. A
Wald statistic can be constructed by <span class="math display">\[\begin{align*}
S_p=(\boldsymbol{C}_p\boldsymbol{\widehat\theta})^T
\left[\boldsymbol{C}_p \{- \triangledown^2
\ell(\boldsymbol{\widehat\theta})\}^{-1}\boldsymbol{C}_p^T\right]^{-1}(\boldsymbol{C}_p\boldsymbol{\widehat\theta}).
\end{align*}\]</span></p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test.zero</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.zero.html">tvef.zero</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span></code></pre></div>
<p>Under the null hypothesis that the effect is time-independent, <span class="math inline">\(S_p\)</span> is asymptotically chi-square
distributed with <span class="math inline">\(K\)</span> degrees of
freedom.</p>
<div class="section level4">
<h4 id="testing-at-each-time-point">Testing at each time point<a class="anchor" aria-label="anchor" href="#testing-at-each-time-point"></a>
</h4>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test.zero.time</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.zero.time.html">tvef.zero.time</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span></code></pre></div>
<p>From the plot above, we could observe that with different knots
selected, the performance is not different so much for different knots,
all the estimates are relatively close to the real function. However, in
the penalized model, the lambda is more important which is another
reason that we need to select the best lambda before actually fitting
the model. The following plot is the performance of different lambda
selected. For the following plot, the knot was set as default, which is
<code>knot=8</code>.</p>
<!-- ## Real Data Example `SUPPORT` -->
<!-- In this section, we illustrate the usage of our package by analyzing the time-varying effects on the real data `SUPPORT` (Study to Understand Prognoses Preferences Outcomes and Risks of Treatment). -->
<!-- We use the processed `SUPPORT` data set included in the R package [@casebase]. -->
<!-- We study the time-varying effects of metastatic cancer as the illustration example and include -->
<!-- First we load the data and get the survival outcome: -->
<!-- ```{r, message = FALSE} -->
<!-- data(support) -->
<!-- time <- support$d.time -->
<!-- death <- support$death -->
<!-- ``` -->
<!-- Age, cancer status and diabetes status are included as covariates and considered as categorical variables. -->
<!-- Age has 4 levels, cancer status has 3 levels and diabetes has 2 levels. -->
<!-- The following codes processed the covariates for model fitting. -->
<!-- ```{r, message = FALSE} -->
<!-- #diabetes: -->
<!-- diabetes <-  model.matrix(~factor(support$diabetes))[,-1] -->
<!-- #sex: female as the reference group -->
<!-- sex <- model.matrix(~support$sex)[,-1] -->
<!-- #age: continuous variable -->
<!-- age <-support$age -->
<!-- age[support$age<=50] <- "<50" -->
<!-- age[support$age>50 & support$age<=60] <- "50-59" -->
<!-- age[support$age>60 & support$age<70] <- "60-69" -->
<!-- age[support$age>=70] <- "70+" -->
<!-- age <- factor(age, levels = c("60-69", "<50", "50-59", "70+")) -->
<!-- z_age <- model.matrix(~age)[,-1] -->
<!-- # cancer status: metastatic, yes, no -->
<!-- ca <- factor(support$ca) -->
<!-- z_ca_mets <- as.numeric(support$ca == "metastatic") -->
<!-- z_ca_non_mets <- as.numeric(support$ca == "yes") -->
<!-- z <- data.frame(z_age, z_ca_mets, z_ca_non_mets, sex, diabetes) -->
<!-- # colnames(z) <- c("age_50", "age_50_59", "age_70", "metastatic", "diabetes", "male") -->
<!-- colnames(z) <- c("age_50", "age_50_59", "age_70", "metastatic", "non_metastatic", "diabetes", "male") -->
<!-- ``` -->
<!-- The Kaplan-Meier (KM) plots were generated using the following codes to visualize the survival probability over time for three categorical variables. Analysis of the KM plot for cancer status revealed a crossover point at approximately day 200, where the survival probability of the non-metastatic cancer group surpassed that of the cancer group, suggesting a violation of the non-proportional hazards assumption. -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- library(survminer) -->
<!-- library(survival) -->
<!-- data <- data.frame(time, death, z) -->
<!-- fit1 <- survfit(Surv(time, death) ~ metastatic + non_metastatic, data = data) -->
<!-- fit2 <- survfit(Surv(time, death) ~ diabetes, data = data) -->
<!-- fit3 <- survfit(Surv(time, death) ~ age_50 + age_50_59 + age_70, data = data) -->
<!-- ggsurvplot(fit1, data = data, legend.labs = c("non-cancer", "non-metastatic cancer", "metastatic cancer")) -->
<!-- ggsurvplot(fit2, data = data, legend.labs = c("diabetes", "non-diabetes")) -->
<!-- ggsurvplot(fit3, data = data, legend.labs = c("60-69", "70+", "50-59", "<50")) -->
<!-- ``` -->
<!-- Fit the Newtons' Method using `coxtv`: -->
<!-- ```{r} -->
<!-- fit.coxtv <- coxtv(event = death, z = z, time = time, nsplines = 10) -->
<!-- ``` -->
<!-- We take a look at the estimation plots of cancer status using the `plot` function: -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- plot(fit.coxtv, parm = c("metastatic", "non_metastatic"), ylim = c(-2,2), ylab = "log hazard ratio") -->
<!-- ``` -->
<!-- Conditioned on the diabetes status and age, we can observe a violation of the proportional hazards assumption. A significant difference in the hazard of death was observed between the metastatic cancer, non-metastatic cancer, and non-cancer groups. Specifically, patients with metastatic cancer exhibited a higher hazard of death during the initial 1500 days compared with non-cancer patients. -->
<!-- However, upon examination of the estimation plot for non-metastatic cancer, a decrease at the beginning followed by an increase can be observed. The fluctuation in the plot is not deemed reliable, primarily due to the instability of the estimation. To address this issue, a penalty term was added to improve the estimation. -->
<!-- ```{r, message = FALSE} -->
<!-- fit.coxtp <- coxtp(event = death, z = z, time = time, lambda = c(1,10,100,1000)) -->
<!-- IC.support <- IC(fit.coxtp) -->
<!-- ``` -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- plot(IC.support$model.mAIC, parm = c("metastatic", "non_metastatic"), ylim = c(-2,2), ylab = "log hazard ratio") -->
<!-- ``` -->
<!-- Then we provide the hypothesis testing for each covariate. -->
<!-- ```{r} -->
<!-- #test the proportional hazards assumption -->
<!-- test.ph <- tvef.ph(fit.coxtv) -->
<!-- print(test.ph) -->
<!-- #test the significance of each covariate -->
<!-- test.zero <- tvef.zero(fit.coxtv) -->
<!-- print(test.zero) -->
<!-- ``` -->
<!-- When testing for the proportional hazards assumption, age_50, non_cancer, non_metastatic, diabetes and male has p-value < 0.05. We reject the null hypothesis and claim that these covariates have violated the proportional hazards assumption. -->
<!-- All these covariates are significant based on the Wald test. -->
<!-- Then we can use the following codes to get the baseline estimation and the baseline plot. -->
<!-- ```{r} -->
<!-- base <- baseline(IC.support$model.TIC) -->
<!-- ``` -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- plot(base) -->
<!-- ``` -->
<!-- When dealing with data where ties are presented, we can also give baseline hazard and absolute hazard for each covariate. -->
<!-- We utilized the Breslow's approximation to estimate the baseline hazard at each event time. We round the unique event time first. -->
<!-- ```{r, message = FALSE} -->
<!-- time.discrete <- round(support$d.time, digits = -2) -->
<!-- fit.discrete <- coxtv(event = death, z = z, time = time.discrete, nsplines = 10) -->
<!-- base.discrete <- baseline(fit.discrete) -->
<!-- ``` -->
<!-- The following codes provide the absolute hazards plot. -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- beta.abso <- data.frame(get.tvcoef(fit.discrete)) -->
<!-- time_unique<- unique(time.discrete) -->
<!-- haz_j      <- base.discrete$hazard -->
<!-- smooth_data <- data.frame(time_unique, haz_j) -->
<!-- loessMod30 <- loess(haz_j ~ time_unique, data=smooth_data, span=0.30) # 30% smoothing -->
<!-- haz_j_smooth30 <- predict(loessMod30) -->
<!-- exp_betax<- matrix(0,length(unique(time.discrete)),dim(z)[2]) -->
<!-- beta2                   <- beta.abso -->
<!-- beta2$cancer         <- 0 -->
<!-- exp_betax               <- exp(beta2) -->
<!-- haz_0_betax             <- haz_j_smooth30 * exp_betax -->
<!-- ``` -->
<!-- ```{r, fig = TRUE, message = FALSE} -->
<!-- library(ggplot2) -->
<!-- plot_age <- ggplot(haz_0_betax, aes(x=time_unique)) + -->
<!--   geom_line(aes(y=metastatic,  color = "metastatic-cancer"),size = 0.6) + -->
<!--   geom_line(aes(y=non_metastatic,    color = "non-metastatic"),size = 0.6) + -->
<!--   geom_line(aes(y=cancer,  color = "non-cancer"),size = 0.6) + -->
<!--   scale_color_manual(name='Age at diagnosis', -->
<!--                      breaks = c('non-cancer', 'non-metastatic', 'metastatic-cancer'), -->
<!--                      values = c('non-cancer'='dark green', 'non-metastatic'='red', 'metastatic-cancer' = 'black')) + -->
<!--   theme(plot.title = element_text(hjust = 0.2)) -->
<!-- plot_age -->
<!-- ``` -->
<!-- ## References -->
<!-- ## Appendix: -->
<!-- ## B-spline basis to represent time-varying effects -->
<!-- To model time-varying coefficients $\beta(t)$, we use a set of B-spline basis functions, providing a flexible and accurate way to capture the nonlinear relationships between predictor variables and the time-to-event outcome over time. B-splines are piecewise polynomial functions that can be smoothly connected at a set of points called knots. The smoothness of the spline function makes it a suitable choice for modeling time-varying effects in survival analysis, as it allows for the estimation of smooth and continuous relationships between predictor variables and the time-to-event outcome. -->
<!-- These B-spline basis functions are generated using the splines R package with a fixed number of basis functions. The number of knots and the degree of the B-spline (typically, cubic B-splines are used) can be adjusted to control the smoothness and complexity of the resulting model. Increasing the number of knots results in a more flexible model that can capture more complex relationships, whereas reducing the number of knots leads to a smoother and simpler model. However, it is essential to strike a balance between flexibility and over-fitting the data when choosing the number of knots and the degree of the B-spline. We introduced the usage of a penalty term in later sections to control the smoothness with a larger number of knots. -->
<!-- To estimate the time-varying coefficients ${\boldsymbol\beta}(t)=\{\beta_{1}(t),\ldots, \beta_{P}(t)\}$, we span $\boldsymbol\beta(\cdot)$ by a set of cubic B-splines defined on a given number of knots: \begin{eqnarray} -->
<!--    \beta_{p}(t)=\boldsymbol\theta_{p}^\top\boldsymbol{B}(t)=\sum_{k=1}^K \theta_{pk} B_k(t), ~~ p=1, \ldots, P,   \nonumber -->
<!-- \end{eqnarray} where $\boldsymbol{B} (t)=\{B_1(t), \ldots, B_K(t)\}^T$ forms a basis, $K$ is the number of basis functions, and $\boldsymbol\theta_{p}=(\theta_{p1}, \ldots, \theta_{pK})^T$ is a vector of coefficients with $\theta_{pk}$ being the coefficient for the $k$-th basis of the $p$-th covariate. -->
<!-- The following plot gives a illustration of the construction of B-spline basis functions.  -->
<!-- ```{r, fig = TRUE, fig.width=7, fig.height=3.5, warning = FALSE} -->
<!-- # Use the example data for illustration: -->
<!-- time.point <- seq(0, 1, length.out = 100) -->
<!-- # Load splines packages -->
<!-- library(splines) -->
<!-- # Set the number of knots and the degree of the B-spline basis functions -->
<!-- nsplines <- 8 -->
<!-- degree <- 3 -->
<!-- # Set the knot location  -->
<!-- knots = quantile(time.point,  (1:(nsplines-degree-1))/(nsplines-degree)) -->
<!-- # Generate B-spline basis functions using the bs() function -->
<!-- basis_functions <- splines::bs(time.point, knots = knots, degree = degree, intercept=T) -->
<!-- # Plot the B-spline basis functions -->
<!-- plot(time.point, basis_functions[,1], type = "l", ylim = c(0, 1), xlab = "Time", ylab = "B-spline basis functions", main = "B-spline basis functions with degree = 3") -->
<!-- for (i in 2:ncol(basis_functions)) { -->
<!--   lines(time.point, basis_functions[,i], col = i) -->
<!-- } -->
<!-- # Add a legend to the plot -->
<!-- legend("topleft", legend = paste("B-spline", 1:ncol(basis_functions)), col = 1:ncol(basis_functions), lty = 1, cex = 0.7) -->
<!-- ``` -->
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Lingfeng Luo, <a href="https://www.wenbowu.me/" class="external-link">Wenbo Wu</a>, <a href="https://www.um-kevinhe-group.org/" class="external-link">Kevin He</a>.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
