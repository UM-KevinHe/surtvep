<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>surtvep • surtvep</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="surtvep">
<meta property="og:description" content="surtvep">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-54921687-5"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-54921687-5');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">surtvep</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/surtvep.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Model_Parameters.html">Model Parameters</a>
    </li>
    <li>
      <a href="../articles/reference.html">Reference</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/UM-KevinHe/surtvep/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>surtvep</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/UM-KevinHe/surtvep/blob/HEAD/vignettes/surtvep.Rmd" class="external-link"><code>vignettes/surtvep.Rmd</code></a></small>
      <div class="hidden name"><code>surtvep.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction:<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p><code>surtvep</code> is an R package for fitting penalized Newton’s
method for the time-varying effects model using mAIC, TIC, GIC as
information criteria, in particular we span the parameter using basis
functions. Utilities for carrying out post-fitting visualization,
summarization, and inference are also provided. In this tutorial we
introduce the use of <code>surtvep</code> through an example
dataset.</p>
</div>
<div class="section level2">
<h2 id="installation">Installation:<a class="anchor" aria-label="anchor" href="#installation"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#Install the package, need to install the devtools packages:</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="st"><a href="https://devtools.r-lib.org/" class="external-link">"devtools"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="st"><a href="https://remotes.r-lib.org" class="external-link">"remotes"</a></span><span class="op">)</span></span>
<span><span class="fu">remotes</span><span class="fu">::</span><span class="fu"><a href="https://remotes.r-lib.org/reference/install_github.html" class="external-link">install_github</a></span><span class="op">(</span><span class="st">"UM-KevinHe/surtvep"</span>, ref <span class="op">=</span> <span class="st">"Lingfeng_test"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#To install with Vignettes:</span></span>
<span><span class="co"># install.packages("devtools")</span></span>
<span><span class="co"># devtools::install_github("UM-KevinHe/surtvep",build_vignettes =T)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="quick-start">Quick Start<a class="anchor" aria-label="anchor" href="#quick-start"></a>
</h2>
<p>The purpose of this section is to give users a general sense of the
package. We will briefly go over the main functions, basic operations
and outputs. After this section, users may have a better idea of what
functions are available, which ones to use, or at least where to seek
help.</p>
<p>First, we load the ‘surtvep’ package:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/UM-KevinHe/surtvep" class="external-link">"surtvep"</a></span><span class="op">)</span></span></code></pre></div>
<p>The main functions used in the package are Newton’s method ‘coxtv’
and Newton’s method combined with penalization ‘coxtp’, which we will
demonstrate in this section. We load a set of data created beforehand
for illustration:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleData"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>The command loads an input covariate matrix ‘z’, time-to-event
outcome ‘time’ and ‘event’ from this saved R data archive. The saved
data set is a simulation data set with continuous outcomes.</p>
<p>We fit the Newton’s method without penalization use the most basic
call to ‘coxtv’.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.tv</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.2982771; Stopping crit = 2.8599513e-01;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.2916285; Stopping crit = 6.4033714e-03;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.2916034; Stopping crit = 2.5024973e-05;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.2916034; Stopping crit = 5.6581492e-10;</span></span></code></pre></div>
<p>‘fit.tv’ is an object of class ‘coxtv’ that contains all the relevant
information of the fitted model for further use. We do not encourage
users to extract the components directly. Instead, various methods are
provided for the object such as <code>plot</code> and <code>test</code>
that enable us to execute those tasks more elegantly.</p>
<p>We can get the time-varying coefficients by calling the
<code>get.tvcoef</code> method:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">beta.tv</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.tvcoef.html">get.tvcoef</a></span><span class="op">(</span><span class="va">fit.tv</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">beta.tv</span><span class="op">)</span></span>
<span><span class="co">#&gt;                             X1          X2</span></span>
<span><span class="co">#&gt; 0.000178354960296403 0.8190941 -0.07539314</span></span>
<span><span class="co">#&gt; 0.000355177544950556 0.8202944 -0.07436044</span></span>
<span><span class="co">#&gt; 0.000532422851851532 0.8214929 -0.07332691</span></span>
<span><span class="co">#&gt; 0.0011332947259668   0.8255221 -0.06983544</span></span>
<span><span class="co">#&gt; 0.00146478440156426  0.8277227 -0.06791732</span></span>
<span><span class="co">#&gt; 0.00224849921081871  0.8328625 -0.06340520</span></span></code></pre></div>
<p>The first row of <code>beta.tv</code> represents the time-varying
coefficient of x1 and x2 at time 0.00017835.</p>
<p>In order to get the time-varying coefficients on a new time sequence,
we can modify the <code>times</code> argument in
<code>get.tvcoef</code>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">time.new</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="va">beta.tv.new</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get.tvcoef.html">get.tvcoef</a></span><span class="op">(</span><span class="va">fit.tv</span>,times <span class="op">=</span> <span class="va">time.new</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">beta.tv.new</span><span class="op">)</span></span>
<span><span class="co">#&gt;            X1         X2</span></span>
<span><span class="co">#&gt; 1   1.0753701  0.7029324</span></span>
<span><span class="co">#&gt; 1.1 1.0529174  0.5242153</span></span>
<span><span class="co">#&gt; 1.2 1.0039703  0.3215421</span></span>
<span><span class="co">#&gt; 1.3 0.9365847  0.1039432</span></span>
<span><span class="co">#&gt; 1.4 0.8590977 -0.1195252</span></span>
<span><span class="co">#&gt; 1.5 0.7798461 -0.3398073</span></span></code></pre></div>
<p>We can visualize the time-varying coefficients by executing the
<code>plot</code> method:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.tv</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-8-1.png" width="672"></p>
<p>Each sub figure corresponds to a variable. It shows the time-varying
effect of our predictors. In our <code>ExampleData</code>, the first
predictor has a constant effect of 1, and the second predictor has a
time-varying effect of <span class="math inline">\(\text{sin}(3\pi *
t/4)\)</span>, where <span class="math inline">\(t\)</span> is the time.
The dotted line indicates the that hazard ratio is 0, which means the
predictor has no effect. Users may also wish to plot the effect of
different covariates in the same plot: this can be done by setting
<code>allinone = TRUE</code> in the plot command.</p>
<p>Next we fit the Newton’s method combined with penalization method. We
specify a range of penalization coefficients first, then call the
<code>coxtp</code> function. Detailed disucussion of how to specify the
range of penalization coefficients and how to choose the appropriate one
will be discussed in section Information Criteria.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_all</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">fit.penalize</span> <span class="op">=</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, lambda <span class="op">=</span> <span class="va">lambda_all</span>, method <span class="op">=</span> <span class="st">"ProxN"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3017443; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.2954100; Stopping crit = 2.0664261e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.2953323; Stopping crit = 2.5346890e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.2953321; Stopping crit = 4.6097119e-07;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -3.2953321; Stopping crit = 1.7713469e-12;</span></span>
<span><span class="co">#&gt; lambda 1 is done.</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.penalize</span><span class="op">$</span><span class="va">lambda1</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>With the tools introduced so far, users are able to fit the
time-varying model. There are many more arguments in the package that
give users a great deal of flexibility. To learn more, move on to later
section.</p>
</div>
<div class="section level2">
<h2 id="newtons-method">Newton’s method<a class="anchor" aria-label="anchor" href="#newtons-method"></a>
</h2>
<p>In this section we introduce the Newton’s method for estimating
time-varying effects in detail.</p>
<p>Let <span class="math inline">\(D_{i}\)</span> denote the time lag
from transplantation to death and <span class="math inline">\(C_{i}\)</span> be the censoring time for patient
<span class="math inline">\(i\)</span>, <span class="math inline">\(i=1,\ldots, n\)</span>. Here <span class="math inline">\(n_j\)</span> is the sample size. The observed time
is <span class="math inline">\(T_{i} = \min\{D_{i},C_{i}\}\)</span>, and
the death indicator is given by <span class="math inline">\(\delta_{i} =
I(D_{i} \leq C_{i})\)</span>. Let <span class="math inline">\(\boldsymbol{X}_{i}=(X_{i1}, \ldots,
X_{iP})^T\)</span> be a <span class="math inline">\(P\)</span>-dimensional covariate vector. We assume
that <span class="math inline">\(D_{i}\)</span> is independent from
<span class="math inline">\(C_{i}\)</span> given <span class="math inline">\(\textbf{X}_{i}\)</span>. Consider the hazard
function <span class="math display">\[
   \lambda(t|\boldsymbol{X}_{i}) =
\lambda_{0}(t)\exp\{\boldsymbol{X}_{i}^T {\boldsymbol\beta}(t)\},
%\nonumber
\]</span> where <span class="math inline">\(\lambda_{0}(t)\)</span> is
the baseline hazard. To estimate the time-varying coefficients <span class="math inline">\({\boldsymbol\beta}(t)=\{\beta_{1}(t),\ldots,
\beta_{P}(t)\}\)</span>, we span <span class="math inline">\(\boldsymbol\beta(\cdot)\)</span> by a set of cubic
B-splines defined on a given number of knots: <span class="math display">\[\begin{eqnarray}
   \beta_{p}(t)=\boldsymbol\theta_{p}^T  \boldsymbol{B}(t)=\sum_{k=1}^K
\theta_{pk} B_k(t), ~~ p=1, \ldots, P,   \nonumber
\end{eqnarray}\]</span> where <span class="math inline">\(\boldsymbol{B}(t)=\{B_1(t), \ldots,
B_K(t)\}^T\)</span> forms a basis, <span class="math inline">\(K\)</span> is the number of basis functions, and
<span class="math inline">\(\boldsymbol\theta_{p}=(\theta_{p1}, \ldots,
\theta_{pK})^T\)</span> is a vector of coefficients with <span class="math inline">\(\theta_{pk}\)</span> being the coefficient for the
<span class="math inline">\(k\)</span>-th basis of the <span class="math inline">\(p\)</span>-th covariate.</p>
<p>With a length-<span class="math inline">\(PK\)</span> parameter
vector <span class="math inline">\(\boldsymbol\theta=vec(\boldsymbol\Theta)\)</span>,
the vectorization of the coefficient matrix <span class="math inline">\(\boldsymbol\Theta=(\boldsymbol\theta_{1}, \ldots,
\boldsymbol\theta_{P})^T\)</span> by row, the log-partial likelihood
function is <span class="math display">\[\begin{equation}
  \ell(\boldsymbol\theta)=\sum_{i=1}^{n_j} \delta_{i} \left
[\boldsymbol{X}_{i}^T \boldsymbol\Theta  \boldsymbol{B}(T_{i})
  -\log
  \left\{\sum_{i' \in R_{i}}  \exp \{\boldsymbol{X}_{i' }^T
\boldsymbol\Theta  \boldsymbol{B}(T_{i}) \} \right \} \right ]
\end{equation}\]</span>, where <span class="math inline">\(R_{i}=\{i': 1 \leq i' \leq n, ~
T_{i'}\geq T_{i}\}\)</span> is the at-risk set.</p>
<p><code>coxtv</code> applies Newton’s method to solve the problem.
Specifically, suppose we have current estimates <span class="math inline">\(\widetilde{\boldsymbol\theta}\)</span>, the update
is <span class="math display">\[
    \widetilde{\boldsymbol\theta} \leftarrow
\widetilde{\boldsymbol\theta} + \nu \boldsymbol{\mu};
\]</span> where <span class="math display">\[
  \boldsymbol{\mu} = \left(- \nabla^2 \ell(\boldsymbol{\theta})
\right)^{-1} \nabla \ell(\boldsymbol{\theta})
\]</span>, and <span class="math inline">\(\nu\)</span> is a step size
adjusted by backtracking linesearch. <span class="math inline">\(\nabla
\ell(\boldsymbol{\theta})\)</span> and <span class="math inline">\(\nabla^2 \ell(\boldsymbol{\theta})\)</span> is the
first and second derivative of the log partial likelihood.</p>
<div class="section level3">
<h3 id="commonly-used-function-arguments">Commonly used function arguments<a class="anchor" aria-label="anchor" href="#commonly-used-function-arguments"></a>
</h3>
<p><code>coxtp</code> provides various arguments for users to customize
the fit: we introduce some commonly used arguments here.</p>
<ul>
<li><p><code>strata</code> is for stratification group defined in the
data used for the stratified model. If there exists a stratification
group, please enter it as a vector. By default, a non-stratified model
would be implemented.</p></li>
<li><p><code>nsplines</code> number of basis functions in the B-splines
to span the time-varying effects, the default value is 8. We use the r
function <code><a href="https://rdrr.io/r/splines/bs.html" class="external-link">splines::bs</a></code> to generate the B-splines. Denoted as
<span class="math inline">\(k\)</span> in our model
introduction.</p></li>
<li><p><code>ties</code> is specifying the method for tie handling. If
there are no tied death times, the methods are equivalent. By default
<code>"Breslow"</code> uses the Breslow approximation, which can be
faster when many ties occur.</p></li>
<li><p><code>tol</code> convergence threshold for Newton’s method. The
algorithm continues until the method selected using <code>stop</code>
converges. The default value is <code>1e-6</code>.</p></li>
<li><p><code>iter.max</code> maximum Iteration number if the stopping
criteria specified by <code>stop</code> is not satisfied. Default value
is 20.</p></li>
<li><p><code>degree</code> degree of the piecewise polynomial for
generating the B-spline basis functions—default is 3 for cubic splines.
<code>degree = 2</code> results in the quadratic B-spline basis
functions.</p></li>
<li><p><code>method</code> a character string specifying whether to use
Newton’s method or Proximal Newton’s method. If <code>"Newton"</code>
then exact hessian is used, while default method <code>"ProxN"</code>
implementing the proximal method which can be faster and more stable
when there exists ill-conditioned second-order information of the
log-partial likelihood.</p></li>
<li><p><code>gammma</code> parameter for Proximal Newton’s Method
<code>"ProxN"</code>. Default value is <code>1e8</code>.</p></li>
<li><p><code>btr</code> a character string specifying the backtracking
line-search approach. <code>"dynamic"</code> is a typical way to perform
backtracking line-search. See details in Convex Optimization by Boyd and
Vandenberghe (2009). <code>"static"</code> limits Newton’s increment and
can achieve more stable results in some extreme cases, such as
ill-conditioned second-order information of the log-partial likelihood,
which usually occurs when some predictors are categorical with low
frequency for some categories. Users should be careful with
<code>static</code> as this may lead to under-fitting.</p></li>
<li><p><code>tau</code> a scalar in (0,1) used to control the step size
inside the backtracking line-search. The default value is 0.5.</p></li>
<li>
<p><code>stop</code> a character string specifying the stopping rule
to determine convergence. Use <span class="math inline">\(loglik(m)\)</span> to denote the log-partial
likelihood at iteration step m.<br></p>
<p><code>"incre"</code> means we stop the algorithm when Newton’s
increment is less than the <code>tol</code>. <code>"relch"</code> means
we stop the algorithm when the <span class="math inline">\(loglik(m)\)</span> divided by the <span class="math inline">\(loglik(0)\)</span> is less than the
<code>tol</code>. <code>"ratch"</code> means we stop the algorithm when
<span class="math inline">\((loglik(m)-loglik(m-1))/(loglik(m)-loglik(0))\)</span>
is less than the <code>tol</code>. <code>"all"</code> means we stop the
algorithm when all the stopping rules <code>"incre"</code>,
<code>"relch"</code> and <code>"ratch"</code> is met. Default value is
<code>ratch</code>. If the maximum iteration steps <code>iter.max</code>
is achieved, the algorithm stops before the stopping rule is
met.</p>
</li>
<li><p><code>parallel</code> if <code>TRUE</code>, then the parallel
computation is enabled. The number of threads in use is determined by
<code>threads</code>.</p></li>
<li><p><code>threads</code> an integer indicating the number of threads
to be used for parallel computation. Default is <code>2</code>. If
<code>parallel</code> is false, then the value of <code>threads</code>
has no effect.</p></li>
<li><p><code>fixedstep</code> fixedstep if <code>TRUE</code>, the
algorithm will be forced to run <code>iter.max</code> steps regardless
of the stopping criterion specified.</p></li>
</ul>
<p>In the following sections we brefily describe these useful arguments
when calling <code>coxtv</code>.</p>
<p>Now we start with a relatively harsh simulated data. Here, the
covariates V1 and V2 were generated as binary variables with around 90%
frequency, which is a relatively harsh setting to be estimated. The
related true log-hazard function for each variable is <span class="math inline">\(\beta(t)=1\)</span> and <span class="math inline">\(\beta(t)=exp(-1.5*t)\)</span>, where t denotes
time.</p>
<p>Let’s check the data first:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleDataBinary"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;    0    1 </span></span>
<span><span class="co">#&gt; 1520  480</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;    0    1 </span></span>
<span><span class="co">#&gt; 1564  436</span></span>
<span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>Both predictors are presented with frequency around 25%.</p>
</div>
<div class="section level3">
<h3 id="proximal-newtons-method-method-proxn">Proximal Newton’s method: <code>method = "ProxN"</code><a class="anchor" aria-label="anchor" href="#proximal-newtons-method-method-proxn"></a>
</h3>
<p>The ‘method’ parameter has two options.
<strong><code>method="Newton"</code></strong> and
<strong><code>method="ProxN"</code></strong>. The proximal Newton’s
method modified the second order derivative <span class="math inline">\(\nabla^2 \ell(\boldsymbol{\theta})\)</span> by
adding small terms <span class="math inline">\(1/\lambda\)</span> to the
the diagonal elements. The default value of <span class="math inline">\(\lambda\)</span> is <span class="math inline">\(10^8\)</span>, which can be modified by user. If
the data set have predictors with extremely low frequency, users may
consider a smaller <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.newton</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, method <span class="op">=</span> <span class="st">'Newton'</span><span class="op">)</span></span>
<span><span class="va">fit.proxN</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, method <span class="op">=</span> <span class="st">'ProxN'</span><span class="op">)</span></span></code></pre></div>
<p>Then we plot the fitted methods with all the curves on the same plot.
No obvious change can be oberserved here. However, we do recommand
using</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.newton</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, allinone <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.proxN</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, allinone <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-13-1.png" width="40%" height="44%"><img src="surtvep_files/figure-html/unnamed-chunk-13-2.png" width="40%" height="44%"></p>
</div>
<div class="section level3">
<h3 id="stratified-newtons-method-strata">Stratified Newton’s Method: <code>strata</code><a class="anchor" aria-label="anchor" href="#stratified-newtons-method-strata"></a>
</h3>
<p>When different facilities are present, we can extend the model to
stratified version. We use <span class="math inline">\(j=1,\ldots,J\)</span> to denote the <span class="math inline">\(J\)</span> different centers Let <span class="math inline">\(D_{ij}\)</span> denote the time lag to death and
<span class="math inline">\(C_{ij}\)</span> be the censoring time for
patient <span class="math inline">\(i\)</span> in center <span class="math inline">\(j\)</span>, <span class="math inline">\(i=1,\ldots, n_j\)</span>, and <span class="math inline">\(j=1, \ldots, J\)</span>. Here <span class="math inline">\(n_j\)</span> is the sample size in center <span class="math inline">\(j\)</span>. The total number of patients is <span class="math inline">\(N=\sum_{j=1}^Jn_j\)</span>, the observed time is
<span class="math inline">\(T_{ij} = \min\{D_{ij},C_{ij}\}\)</span>, and
the death indicator is given by <span class="math inline">\(\delta_{ij}
= I(D_{ij} \leq C_{ij})\)</span>.<br></p>
<p>Let <span class="math inline">\(\textbf{X}_{ij}=(X_{ij1}, \ldots,
X_{ijP})^T\)</span> be a <span class="math inline">\(P\)</span>-dimensional covariate vector. We assume
that <span class="math inline">\(D_{ij}\)</span> is independent from
<span class="math inline">\(C_{ij}\)</span> given <span class="math inline">\(\textbf{X}_{ij}\)</span>. Correspondingly, the
log-partial likelihood function is <span class="math display">\[
    \ell_{strata}(\boldsymbol\theta) = \sum_{j=1}^J \sum_{i=1}^{n_j}
\delta_{ij} \left [\boldsymbol{X}_{ij}^T
\boldsymbol\Theta  \boldsymbol{B}(T_{ij})
    -\log
    \left\{\sum_{i' \in R_{ij}}  \exp \{\boldsymbol{X}_{i' j}^T
\boldsymbol\Theta  \boldsymbol{B}(T_{ij}) \} \right \} \right ],
\]</span> where <span class="math inline">\(R_{ij}=\{i': 1 \leq
i' \leq n_j, ~ T_{i' j}\geq T_{ij}\}\)</span> is the at-risk set
for stratum <span class="math inline">\(j\)</span>.</p>
<p>For the case with different stratums, usage is to include
<code>strata</code> variable. First, we load a set of generated data
with different stratums. In our simulation, we vary the baseline for
different stratums by adding a small term generated by uniform
distribution with mean = 0 and standard deviation= 0.5.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"StrataExample"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">event</span></span>
<span><span class="va">strata</span> <span class="op">&lt;-</span> <span class="va">StrataExample</span><span class="op">$</span><span class="va">strata</span></span></code></pre></div>
<p>The <code>strata</code> variable can be a <code>ns &gt;= 1</code>
level factor, numerical numbers or strings. The stratified model can be
easily fitted by calling</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.strata</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>z <span class="op">=</span> <span class="va">z</span>, event <span class="op">=</span> <span class="va">event</span>, time<span class="op">=</span><span class="va">time</span>, strata <span class="op">=</span> <span class="va">strata</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.strata</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-15-1.png" width="672"></p>
</div>
<div class="section level3">
<h3 id="step-size-adjustment-btr">Step size adjustment: <code>btr</code><a class="anchor" aria-label="anchor" href="#step-size-adjustment-btr"></a>
</h3>
<div class="section level4">
<h4 id="model-results-meanings">Model results meanings:<a class="anchor" aria-label="anchor" href="#model-results-meanings"></a>
</h4>
<p>First, Let’s look at the <code>fit</code> result</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># summary(fit.tv)</span></span></code></pre></div>
<p>There are 4 results saved under the fit result.</p>
<ul>
<li><p><code>model_result</code> save the detailed model results which
we will explain in a minute.</p></li>
<li><p><code>lambda.selected</code> saved the best lambda chosen based
on different criteria which will not be used for the non-penalized
model.</p></li>
<li><p><code>p</code> refers to the number of covariates used in the
model</p></li>
<li><p><code>z_names</code> records the covariates names.</p></li>
</ul>
<p>The detailed model result was saved in <code>model_result</code>,
which can be called by <code>fit$model_result</code>. Now, let’s explore
the result a little bit:</p>
<p>Here we noticed that there are 16 items in the model results list.
Following is an explanation of each item:</p>
<ul>
<li>
<code>theta</code>: Estimation matrix of <span class="math inline">\(\theta\)</span>
</li>
<li>
<code>logplkd</code>: log-partial likelihood</li>
<li>
<code>theta.all</code>: Internal validation use</li>
<li>
<code>theta.list</code>: The estimation matrix at each Newton’s
update</li>
<li>
<code>AIC.all</code>: Akakia information criterion</li>
<li>
<code>TIC.all</code>: Takeuchi information criterion</li>
<li>
<code>GIC.all</code>: Generalized information criterion</li>
<li>
<code>AIC.trace</code>: Internal validation use</li>
<li>
<code>TIC.trace</code>: Internal validation use</li>
<li>
<code>GIC.trace</code>: Internal validation use</li>
<li>
<code>logplkd.vec</code>: log-partial likelihood at each
iteration</li>
<li>
<code>SplineType</code>: spline used for fitting the model</li>
<li>
<code>VarianceMatrix</code>: Variance Matrix</li>
<li>
<code>uniqfailtimes</code>: The input unique event times if
<code>ties="Breslow"</code>, input time points if
<code>ties="None"</code> (Add link)</li>
<li>
<code>bases</code>: The basis function used for estimating
time-varying effects</li>
<li>
<code>knots</code>: Number of basis functions used for estimating
time-varying effects</li>
</ul>
</div>
<div class="section level4">
<h4 id="how-to-get-the-effect-of-a-specific-time-point">4.1.2.2: How to get the effect of a specific time point?<a class="anchor" aria-label="anchor" href="#how-to-get-the-effect-of-a-specific-time-point"></a>
</h4>
<p>We are more interested in estimating time-varying effect of the
covariates. Following is an simple tutorial of how to do that. First, a
little background about the time-varying effect in cox model(You could
also check this part at our paper which have more detailed
explanation.(insert link))</p>
<p>If we Let <span class="math inline">\(X_i=(X_{i1},X_{i2},...X_{ip})^T\)</span> refers to
the <span class="math inline">\(i_{th}\)</span> individuals in the
dataset with p covariates(which could also be understand as the <span class="math inline">\(i_{th}\)</span> row in the data we extract above).
Let <span class="math inline">\(\lambda(t|X_i)\)</span> denote the
hazard of having the event at time t for the <span class="math inline">\(i_{th}\)</span> individual, <span class="math inline">\(\lambda_0(t)\)</span> denote the hazard of having
the event at time 0. When we considering the covarites having time fixed
effect, we have the following formula for <span class="math inline">\(\lambda(t|X_i)\)</span>:</p>
<p><span class="math inline">\(\lambda(t|X_i)=\lambda_0(t)exp(X_i^T\beta)\)</span></p>
<p>Where <span class="math inline">\(\beta\)</span> refers to the
coefficients where <span class="math inline">\(\beta=(\beta_1,\beta_2,...\beta_p)\)</span>, which
in this example, is (V1, V2). Which have similar format as the GLM
model. For time-varying effect model, we are simply replace <span class="math inline">\(\beta\)</span> with a set of <span class="math inline">\(\beta(t)\)</span>. Thus, the time varying
equations could be transferred as following:</p>
<p><span class="math inline">\(\lambda(t|X_i)=\lambda_0(t)exp(X_i^T\beta(t))\)</span></p>
<p>Similar, <span class="math inline">\(\beta(t)=(\beta_1(t),\beta_2(t),...\beta_p(t))\)</span>
where <span class="math inline">\(\beta(.)\)</span> refers to a set of
cubic B-spline(Details for B-spline refers to here : insert link).
Where, the single <span class="math inline">\(\beta_p(t)\)</span> could
be estimated using the following formula:</p>
<p><span class="math inline">\(\beta_p(t)=\theta_p^TB(t)=\sum_{k=1}^K\theta_{pk}B_k(t)\)</span></p>
<p>Here, K refers to the given number of knots.</p>
<p>Thus, to calculate the time varying effect of coefficient p, we just
need to get both estimated B spline and the <span class="math inline">\(\theta\)</span> matrix. The B-spline was saved in
<code>model_result$bases</code> and <span class="math inline">\(\theta\)</span> matrix was saved in the last item
in <code>model_result$theta_list</code> Following is the code for
calculation:</p>
<p>As a result, <span class="math inline">\(\beta\)</span> is a 2487*2
matrix(we are using the “Breslow” ties, thus there are 2487 rows instead
of 5000, detail about ties and Breslow ties could refers to here(insert
link)).</p>
<p>We could also get the 95%CI for the estimation by the
<code>confint.surtiver</code></p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">CI</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/confint.html" class="external-link">confint</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">CI</span><span class="op">$</span><span class="va">tvef</span><span class="op">$</span><span class="va">X1</span><span class="op">)</span></span>
<span><span class="co">#&gt;                           est     2.5%    97.5%</span></span>
<span><span class="co">#&gt; 0.000201305374503136 1.915036 1.094259 2.735813</span></span>
<span><span class="co">#&gt; 0.000913836294785142 1.900685 1.099472 2.701898</span></span>
<span><span class="co">#&gt; 0.000952352538988396 1.899914 1.099747 2.700081</span></span>
<span><span class="co">#&gt; 0.00131430392382309  1.892692 1.102301 2.683083</span></span>
<span><span class="co">#&gt; 0.00156992387894415  1.887617 1.104068 2.671167</span></span>
<span><span class="co">#&gt; 0.00167505841328876  1.885536 1.104787 2.666286</span></span></code></pre></div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="newton-method-with-penalization">Newton Method with penalization:<a class="anchor" aria-label="anchor" href="#newton-method-with-penalization"></a>
</h2>
<p>The proximal Newton can help improve the estimation when the
origional hessian matrix is very close to a singular one, which may
often occur in the setting of time-varying effects, however,
over-fitting issue still exists. We further improve the estimation by
introducing the penalty. The basic idea of penalization is to control
the model’s smoothness by adding a ‘wiggliness’ penalty to the fitting
objective. Rather than fitting the non-proportional hazards model by
maximizing original log-partial likelihood, it could be fitted by
maximizing <span class="math display">\[\begin{align}
    \ell(\boldsymbol{\theta}) - P_\lambda(\boldsymbol{\theta}).
\end{align}\]</span></p>
<p>We have different choices of <span class="math inline">\(P_\lambda(\boldsymbol{\theta})\)</span>. Potential
choices are to use P-splines, and discrete penalties. Detailed
discussions are provided below.</p>
<div class="section level3">
<h3 id="p-spline">P-spline<a class="anchor" aria-label="anchor" href="#p-spline"></a>
</h3>
<p>The P-splines are low rank smoothers using a B-spline basis, usually
defined on evenly spaced knots, with a difference penalty applied
directly to the parameters <span class="math inline">\(\theta_{pk}\)</span>, to control function
wiggliness. When we set standard cubic B-spline basis functions, the
penalty function used for <span class="math inline">\(\beta_p\)</span>
will be <span class="math display">\[\begin{align*}
    P_\lambda(\boldsymbol{\theta}) =
\lambda\sum_{j=1}^P\sum_{k=1}^{K-1}\{(\boldsymbol{\theta}_{j(k+1)}  -
\boldsymbol{\theta}_{jk})\}^2.
\end{align*}\]</span></p>
<p>It is straight forward to express the penalty as a quadratic form,
<span class="math inline">\(\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}\)</span>,
in this basis coefficients:</p>
<span class="math display">\[\begin{align*}
    \sum_{k=1}^{K-1}\{(\boldsymbol{\theta}_{j(k+1)}  -
\boldsymbol{\theta}_{jk})\}^2
    =
        \boldsymbol{\theta}^T
    \begin{bmatrix}
        1 &amp; -1 &amp; 0 &amp; 0 &amp; . &amp; . &amp; . \\
        -1 &amp; 2  &amp; -1 &amp; 0 &amp; 0 &amp; . &amp; . \\
        0 &amp; -1  &amp; 2 &amp; -1 &amp; 0 &amp; 0 &amp; . \\
        . &amp; . &amp; . &amp; . &amp; . &amp; . &amp; .\\
        . &amp; . &amp; . &amp; . &amp; . &amp; . &amp; .\\
    \end{bmatrix}
    \boldsymbol{\theta}
\end{align*}\]</span>
<p>Hence the penalized fitting problem is to maximize <span class="math display">\[\begin{align}
    \ell(\boldsymbol{\theta}) -
\lambda\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}
\end{align}\]</span> with respect to <span class="math inline">\(\boldsymbol{\theta}\)</span>.</p>
</div>
<div class="section level3">
<h3 id="smoothing-spline">Smoothing-spline<a class="anchor" aria-label="anchor" href="#smoothing-spline"></a>
</h3>
<p>The reduced rank spline smoothers with derivative based penalties can
be set up almost as easily, while retaining the sparsity of the basis
and penalty and the ability to mix-and-match the orders of spline basis
functions and penalties.</p>
<p>We denote the B-spline basis as of order <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_1
= 3\)</span> denotes a cubic spline. Associated with the spline will be
a derivative based penalty <span class="math display">\[\begin{align*}
    P_{\lambda} = \lambda \int_{0}^{T}\boldsymbol{\beta}^{[m_2]}(t)^2dt
\end{align*}\]</span> where <span class="math inline">\(\boldsymbol{\beta}^{[m_2]}(t)\)</span> denotes the
<span class="math inline">\(m_2^{th}\)</span> derivative of <span class="math inline">\(\boldsymbol{\beta}\)</span> with respect to <span class="math inline">\(t\)</span>. It is assumed that <span class="math inline">\(m_2 \leq m_1\)</span>, otherwise it makes no sense
that the penalty is formulated in terms of a derivative that is not
properly defined for the basis functions. Similarly, <span class="math inline">\(P_{\lambda}\)</span> can be written as <span class="math inline">\(\boldsymbol{\theta}^T\boldsymbol{S}\boldsymbol{\theta}\)</span>
where <span class="math inline">\(\boldsymbol{S}\)</span> is a banded
diagonal matrix of known coefficients. The algebraic expression of <span class="math inline">\(\boldsymbol{S}\)</span> is complex, as discussed
in . However, this has little impact on the computation time.</p>
<p>###Usage The usage of Newton Method with penalization
<code>coxtp</code> is very similar as <code>coxtv</code> introduced
above. The main difference comes from the penalization tuning parameter
selection.</p>
<p>We use the smooth spline here for penalization (default). You could
also use <code>spline="P-spline"</code>. For tuning parameter
<code>lambda</code>, you could either enter a numeric number or a vector
of numbers. If <code>lambda</code> was entered as a vector of numbers,
the tuning parameter can be selected based on different criteria(AIC,
TIC or GIC) using function <code>IC</code>. Or users can use
<code>cv.coxtp</code> to select the tuning parameter based on cross
validation. Following is a model fit with the <code>lambda</code> as a
vector for different illustration purposes. We use the relatively harsh
setting <code>ExampleDataBinary</code> to illustrate the useage of
‘coxtp’, ‘IC’ and ‘cv.coxtp’, the penalization method. This setting
contains binary predictors with low frequency, which may have
ill-conditioned second-order information of the log-partial likelihood.
Penalization plays an important role here as it helps to smooth the
time-varying effects.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">ExampleDataBinary</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleDataBinary</span><span class="op">$</span><span class="va">event</span></span></code></pre></div>
<p>First we fit the penalized model with
<code>"Smooth-spline"</code>.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_spline_all</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.01</span>,<span class="fl">0.1</span>,<span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># fit.pspline &lt;- coxtp(event = event, z = z, time = time, lambda=lambda_spline_all, spline = "P-spline")</span></span>
<span><span class="va">fit.smoothspline</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">event</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time</span>, lambda_spline<span class="op">=</span><span class="va">lambda_spline_all</span>, spline <span class="op">=</span> <span class="st">"Smooth-spline"</span><span class="op">)</span></span></code></pre></div>
<p>Then we use the <code>IC</code> function to select the tuning
parameter.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">IC</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/IC.html">IC</a></span><span class="op">(</span><span class="va">fit.smoothspline</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">mAIC</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">TIC</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">GIC</span><span class="op">)</span></span></code></pre></div>
<p>We can directly call the <code>plot</code> function to give the
estimation plot.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">IC</span><span class="op">$</span><span class="va">model.TIC</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-21-1.png" width="40%" height="44%"></p>
<p>From the result above, we noticed that with different selection
criteria, the best lambda selected is different. Here, we use the AIC
criteria which set <code>lambda=1000</code>. The result for this model
was saved in related criteria model and could be called as below:</p>
<!-- ```{r} -->
<!-- AIC_model  = fit_penalized$model.AIC -->
<!-- summary(AIC_model) -->
<!-- ``` -->
<p>Compare with the non-penalized Model, we could see that the effect of
“V1” was shrink to roughly linear in the penalized model.</p>
<p>The detail calculation of B-spline matrix, <span class="math inline">\(\theta\)</span> matrix and <span class="math inline">\(\beta\)</span> matrix was similar as Newton’s
method.</p>
</div>
<div class="section level3">
<h3 id="baseline-estimation">Baseline estimation<a class="anchor" aria-label="anchor" href="#baseline-estimation"></a>
</h3>
<p>The Nelson-Aalen estimator (Breslow estimator) of the culmulative
function is given by <span class="math inline">\(\widetilde{\Lambda}(t)
= \int_0^t \widetilde{\Lambda}_0(u)\)</span>, where <span class="math inline">\(\widetilde{\Lambda}(t)\)</span> is 0 except at the
observed failure times <span class="math inline">\(t_i\)</span>, where
it takes the value <span class="math display">\[\begin{align*}
    d\Lambda_0 = {d_i}\left\{\mathop{\sum}\limits_{\ell \in R(T_i)} \exp
\{\boldsymbol{X}_{i' }^T \boldsymbol{\Theta}  \boldsymbol{B}(T_{i})
\}\right\}^{-1}.
\end{align*}\]</span></p>
<p>The baseline estimation here refers to the baseline hazard at time t
when holding all the covariates equals to zero. We use the model fitted
result <code>fit_penalized</code> in section 4.2.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"ExampleData"</span><span class="op">)</span></span>
<span><span class="va">z</span>     <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">time</span>  <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="va">event</span> <span class="op">&lt;-</span> <span class="va">ExampleData</span><span class="op">$</span><span class="va">event</span></span>
<span></span>
<span><span class="va">time2</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">time</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda_spline_all</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">1</span>,<span class="fl">10</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">fit.smoothspline</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">event</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time2</span>, lambda<span class="op">=</span><span class="va">lambda_spline_all</span>, penalty <span class="op">=</span> <span class="st">"Smooth-spline"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3551771; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.3500715; Stopping crit = 1.8372984e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.3500328; Stopping crit = 1.3917288e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.3500327; Stopping crit = 3.0106586e-07;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -3.3500327; Stopping crit = 2.7706982e-12;</span></span>
<span><span class="co">#&gt; lambda 0.1 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3584050; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.3534872; Stopping crit = 1.7917577e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.3534313; Stopping crit = 2.0350508e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.3534312; Stopping crit = 2.9285592e-07;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -3.3534312; Stopping crit = 6.8426414e-13;</span></span>
<span><span class="co">#&gt; lambda 1 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3657596; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.3617116; Stopping crit = 1.5203960e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.3616821; Stopping crit = 1.1071394e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.3616821; Stopping crit = 4.5050421e-08;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -3.3616821; Stopping crit = 1.6677702e-14;</span></span>
<span><span class="co">#&gt; lambda 10 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -3.3732581; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -3.3702700; Stopping crit = 1.1595777e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -3.3702564; Stopping crit = 5.2957390e-05;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -3.3702564; Stopping crit = 5.4156966e-09;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -3.3702564; Stopping crit = 1.7232601e-15;</span></span>
<span><span class="co">#&gt; lambda 100 is done.</span></span>
<span><span class="va">IC</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/IC.html">IC</a></span><span class="op">(</span><span class="va">fit.smoothspline</span><span class="op">)</span></span>
<span><span class="va">fit.mAIC</span> <span class="op">&lt;-</span> <span class="va">IC</span><span class="op">$</span><span class="va">model.mAIC</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base.est</span> <span class="op">=</span> <span class="fu"><a href="../reference/baseline.html">baseline</a></span><span class="op">(</span><span class="va">fit.mAIC</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">base.est</span><span class="op">)</span></span>
<span><span class="co">#&gt; $time</span></span>
<span><span class="co">#&gt;  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8</span></span>
<span><span class="co">#&gt; [20] 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $hazard</span></span>
<span><span class="co">#&gt;  [1] 0.02576925 0.04632723 0.04796684 0.05258371 0.04708783 0.04544031</span></span>
<span><span class="co">#&gt;  [7] 0.05096521 0.03807625 0.04421912 0.05162255 0.05153851 0.06367847</span></span>
<span><span class="co">#&gt; [13] 0.04167940 0.04678650 0.04840596 0.06907205 0.05280167 0.04285638</span></span>
<span><span class="co">#&gt; [19] 0.02951995 0.02536585 0.02495845 0.02703002 0.03259201 0.03841546</span></span>
<span><span class="co">#&gt; [25] 0.01788728 0.02645356 0.02097025 0.00000000 0.03385874 0.00000000</span></span>
<span><span class="co">#&gt; [31] 0.00000000</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $cumulHaz</span></span>
<span><span class="co">#&gt;  [1] 0.02576925 0.07209648 0.12006331 0.17264703 0.21973486 0.26517517</span></span>
<span><span class="co">#&gt;  [7] 0.31614038 0.35421663 0.39843575 0.45005830 0.50159681 0.56527528</span></span>
<span><span class="co">#&gt; [13] 0.60695468 0.65374117 0.70214714 0.77121918 0.82402086 0.86687724</span></span>
<span><span class="co">#&gt; [19] 0.89639719 0.92176304 0.94672149 0.97375150 1.00634352 1.04475898</span></span>
<span><span class="co">#&gt; [25] 1.06264625 1.08909982 1.11007006 1.11007006 1.14392881 1.14392881</span></span>
<span><span class="co">#&gt; [31] 1.14392881</span></span></code></pre></div>
<!-- ```{r,fig.height = 7, fig.width = 7, fig.align = "center"} -->
<!-- event=sim_data[,"event"] -->
<!-- time=sim_data[,"time"] -->
<!-- data=sim_data[,!colnames(sim_data) %in% c("event","time")] -->
<!-- model1  = fit_penalized$model.AIC -->
<!-- ##baseline -->
<!-- plotdata=coxtp.baseline(fit=model1, delta=event,z=data,time=time) -->
<!-- head(plotdata) -->
<!-- ``` -->
<!-- Let's check the result of baseline function first. -->
<!-- The function returned a dataset containing the baseline estimation including 3 variables: -->
<!-- -   `unique.time.`: The unique time listed in the original dataset used to fit the model -->
<!-- -   `lambda`: refers to $\lambda_0(t)$ in the model, which is baseline hazard -->
<!-- -   `Lambda`: refers to the cumulative baseline hazard in the model. -->
<!-- Note that since our baseline estimation is based on Breslow Estimator, when there is no ties in the data, the baseline estimation could sometime results as 0 since there is no death at certain time-point. -->
<!-- Thus, if we directly draw the plot, it would be something like this: -->
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- #Exclude censoring points -->
<!-- baseline_plot<-ggplot(plotdata,aes(x=unique.time., y=lambda)) + geom_line(size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) + -->
<!--   scale_y_continuous(name='baseline hazard', limits=c(0,0.1)) + -->
<!--   ggtitle(" Baseline Hazard by time") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- baseline_plot -->
<!-- ``` -->
<p>As a result, we could either increase the time interval to make ties
exists or remove the points that have <span class="math inline">\(\lambda=0\)</span>. The only differences would
result in the baseline hazard, there is no influence on the cumulative
baseline hazard.</p>
<!-- ```{r} -->
<!-- plotdata=plotdata[plotdata$lambda!=0,] -->
<!-- ``` -->
<!-- Next, we are going to visualize the result using `ggplot2` and `cowplot` function. -->
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- #Exclude censoring points -->
<!-- baseline_plot<-ggplot(plotdata,aes(x=unique.time., y=lambda)) + geom_line(size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) + -->
<!--   scale_y_continuous(name='baseline hazard', limits=c(0,0.1)) + -->
<!--   ggtitle(" Baseline Hazard by time") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- cum_plot<-ggplot(plotdata,aes(x=unique.time., y=Lambda)) + geom_line(size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) + -->
<!--   scale_y_continuous(name='Cumulative baseline hazard') + -->
<!--   ggtitle("Cumulative Baseline Hazard by time") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- plot_grid(baseline_plot,cum_plot,ncol = 2) -->
<!-- ``` -->
<p>One use of Cumulative baseline hazard is to calculate the survival
function where cumulative hazard is the negative log of the survival
probabilities. If we assume cumulative baseline hazard function as <span class="math inline">\(S(t)\)</span> and cumulative hazard function as
<span class="math inline">\(H(t)\)</span>, then we have <span class="math inline">\(H(t)=-log(S(t))\)</span>. Thus, we could plot the
survival function as follows:</p>
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- plotdata$survive=exp(-plotdata$Lambda) -->
<!-- ggplot(plotdata,aes(x=unique.time., y=survive)) + geom_line(size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis', limits=c(0,3), breaks=c(0,1,2,3)) + -->
<!--   scale_y_continuous(name='Survival Function') + -->
<!--   ggtitle("Survival by time") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- ``` -->
</div>
</div>
<div class="section level2">
<h2 id="hypothesis-tests-for-the-model">Hypothesis Tests for the model<a class="anchor" aria-label="anchor" href="#hypothesis-tests-for-the-model"></a>
</h2>
<p>In this section we provide three tests for the model. The first is to
test</p>
<div class="section level3">
<h3 id="testing-for-time-varying-effect">Testing for time-varying effect<a class="anchor" aria-label="anchor" href="#testing-for-time-varying-effect"></a>
</h3>
<p>To test whether the effects are time-varying, we use the constant
property of B-splines, that is, if <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK},\)</span> the
corresponding covariate effect is time-independent. Specify a matrix
<span class="math inline">\(\boldsymbol{C}_p\)</span> such that <span class="math inline">\(\boldsymbol{C}_p\boldsymbol\theta=\textbf{0}\)</span>
corresponds to the contrast that <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK}\)</span>. A Wald
statistic can be constructed by <span class="math display">\[\begin{align*}
S_p=(\boldsymbol{C}_p\boldsymbol{\widehat\theta})^T
\left[\boldsymbol{C}_p \{- \triangledown^2
\ell(\boldsymbol{\widehat\theta})\}^{-1}\boldsymbol{C}_p^T\right]^{-1}(\boldsymbol{C}_p\boldsymbol{\widehat\theta}).
\end{align*}\]</span></p>
<p>Under the null hypothesis that the effect is time-independent, <span class="math inline">\(S_p\)</span> is asymptotically chi-square
distributed with <span class="math inline">\(K-1\)</span> degrees of
freedom.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tvef.ph.html">tvef.ph</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span>
<span><span class="co">#&gt;        chisq df          p</span></span>
<span><span class="co">#&gt; X1  6.889955  7 0.44042707</span></span>
<span><span class="co">#&gt; X2 21.437089  7 0.00317433</span></span></code></pre></div>
<p>For the second variable, We reject the null hypothesis and claim it
has the time varying effect.</p>
</div>
<div class="section level3">
<h3 id="testing-for-beta-effect">Testing for beta effect<a class="anchor" aria-label="anchor" href="#testing-for-beta-effect"></a>
</h3>
<p>To test whether the effects are significant or not, we use the test
statistic <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK} =
0,\)</span> the corresponding covariate effect is time-independent.
Specify a matrix <span class="math inline">\(\boldsymbol{C}_p\)</span>
such that <span class="math inline">\(\boldsymbol{C}_p\boldsymbol\theta=\textbf{0}\)</span>
corresponds to the contrast that <span class="math inline">\(\theta_{p1}=\cdots=\theta_{pK} = 0\)</span>. A
Wald statistic can be constructed by <span class="math display">\[\begin{align*}
S_p=(\boldsymbol{C}_p\boldsymbol{\widehat\theta})^T
\left[\boldsymbol{C}_p \{- \triangledown^2
\ell(\boldsymbol{\widehat\theta})\}^{-1}\boldsymbol{C}_p^T\right]^{-1}(\boldsymbol{C}_p\boldsymbol{\widehat\theta}).
\end{align*}\]</span></p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test.zero</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.zero.html">tvef.zero</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span></code></pre></div>
<p>Under the null hypothesis that the effect is time-independent, <span class="math inline">\(S_p\)</span> is asymptotically chi-square
distributed with <span class="math inline">\(K\)</span> degrees of
freedom.</p>
<div class="section level4">
<h4 id="testing-at-each-time-point">Testing at each time point<a class="anchor" aria-label="anchor" href="#testing-at-each-time-point"></a>
</h4>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test.zero.time</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.zero.time.html">tvef.zero.time</a></span><span class="op">(</span><span class="va">fit.proxN</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="model-prediction">Model prediction:<a class="anchor" aria-label="anchor" href="#model-prediction"></a>
</h2>
<div class="section level3">
<h3 id="simple-prediction">Simple prediction<a class="anchor" aria-label="anchor" href="#simple-prediction"></a>
</h3>
<p>To predict the new data, we offered the function coxtp.predict. This
function could also be used to calculate absolute hazard. Suppose the
new data to be predicted is <code>c(1,1,0,0,0)</code> for
<code>V1</code> to <code>V5</code>. For data with no stratification:
(Suppose we already have the best tuning parameter
<code>lambda_spline</code> selected).</p>
<!-- ```{r} -->
<!-- sim_data=sim_data_p5 -->
<!-- event=sim_data[,"event"] -->
<!-- time=sim_data[,"time"] -->
<!-- data=sim_data[,!colnames(sim_data) %in% c("event","time")] -->
<!-- lambda_spline=1000 -->
<!-- fit_penalized <- coxtp(event = event, z = data, time = time,lambda_spline=lambda_spline) -->
<!-- model_result  = fit_penalized$model_result -->
<!-- baseline=coxtp.baseline(fit=model_result, delta=event,z=data,time=time) -->
<!-- data_predict=c(1,1,0,0,0) -->
<!-- predict=coxtp.predict(model_result,baseline,newdata=data_predict) -->
<!-- ``` -->
<!-- The result dataset `predict` is a dataset with predicted hazard and time points in the orginal dataset. -->
<!-- We could plot the data using ggplot: -->
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- ggplot(predict,aes(x=unique.time.,y=lambda0_exp_betax)) + -->
<!--   geom_line(size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis') + -->
<!--   scale_y_continuous(name='Predicted hazard') + -->
<!--   ggtitle("Predicted Hazard") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- ``` -->
</div>
<div class="section level3">
<h3 id="absolute-hazard">5.6.2 absolute hazard<a class="anchor" aria-label="anchor" href="#absolute-hazard"></a>
</h3>
<p>If we want to calculate and show the difference of absolute hazard
for variable <code>V2</code>, we could use the
<code>coxtp.predict</code> to get it done. Assume that besides
<code>V2</code>, other covariate are all set to the reference level.</p>
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- data_predict0=c(0,1,0,0,0) -->
<!-- predict0=coxtp.predict(model_result,baseline,newdata=data_predict0,strata = F) -->
<!-- data_predict1=c(0,0,0,0,0) -->
<!-- predict1=coxtp.predict(model_result,baseline,newdata=data_predict1,strata = F) -->
<!-- ggplot() + -->
<!--   geom_line(aes(x=predict0$unique.time.,y=predict0$lambda0_exp_betax,color="V2=0"),size = 0.6) + -->
<!--   geom_line(aes(x=predict1$unique.time.,y=predict1$lambda0_exp_betax,color="V2=1"),size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis') + -->
<!--   scale_y_continuous(name='Predicted hazard') + -->
<!--   ggtitle("Predicted Hazard") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- ``` -->
<!-- ### 5.6.3 Prediction for certain time points -->
<!-- Also, we could specify the time points of output by define `out_seq`. -->
<!-- Following is an example: -->
<!-- Let's check the output first: -->
<!-- ```{r} -->
<!-- predict_seq=coxtp.predict(model_result,baseline,newdata=data_predict,strata = F,out_seq=seq(0,3,by=0.5)) -->
<!-- predict_seq -->
<!-- ``` -->
<!-- Instead of outputing all the data points, the `coxtp.predict` will only output the time points that has been specified. -->
<!-- Next, we are going to see if there is any difference between the one with default output and the one with specified time points: -->
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- predict_seq=coxtp.predict(model_result,baseline,newdata=data_predict,strata = F,out_seq=seq(0,3,by=0.1)) -->
<!-- plot_or=ggplot(predict,aes(x=unique.time.,y=lambda0_exp_betax)) + -->
<!--           geom_line(size = 0.6) + -->
<!--           scale_x_continuous(name='Years since diagnosis') + -->
<!--           scale_y_continuous(name='Predicted hazard') + -->
<!--           ggtitle("Without specify out_seq") + -->
<!--           theme(plot.title = element_text(hjust = 0.5)) -->
<!-- plot_seq=ggplot(predict_seq,aes(x=unique.time.,y=lambda0_exp_betax)) + -->
<!--           geom_line(size = 0.6) + -->
<!--           scale_x_continuous(name='Years since diagnosis') + -->
<!--           scale_y_continuous(name='Predicted hazard') + -->
<!--           ggtitle("With specify out_seq") + -->
<!--           theme(plot.title = element_text(hjust = 0.5)) -->
<!-- plot_grid(plot_or,plot_seq,ncol = 2) -->
<!-- ``` -->
<p>From the result above, we could notice that only the function
smoothness looks different.</p>
<!-- ### 5.6.3 Prediction with stratification -->
<p>For data with stratification, just define that
<code>strata=T</code>(Default is FALSE):(Again, suppose we already have
the best tuning parameter lambda selected)</p>
<!-- ```{r} -->
<!-- event_stra=sim_data_p5_f5[,"event"] -->
<!-- time_stra=sim_data_p5_f5[,"time"] -->
<!-- data_stra=sim_data_p5_f5[,!colnames(sim_data_p5_f5) %in% c("event","time","facility")] -->
<!-- facility=sim_data_p5_f5[,"facility"] -->
<!-- #select best lambda -->
<!-- lambda_spline=1000 -->
<!-- fit_stra<-coxtp(event=event_stra,z=data_stra,time=time_stra,strata =facility,lambda_spline=lambda_spline) -->
<!-- model_result  = fit_stra$model_result -->
<!-- baseline_strata=coxtp.baseline(fit=model_result, delta=event_stra,z=data_stra,time=time_stra,strata = facility) -->
<!-- data_predict=c(1,1,0,0,0) -->
<!-- predict=coxtp.predict(model_result,baseline_strata,newdata=data_predict,strata = T) -->
<!-- ``` -->
<p>Again, we could plot the result by ggplot:</p>
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center",message=FALSE} -->
<!-- ggplot(predict,aes(x=unique.time.,y=lambda0_exp_betax)) + -->
<!--   geom_line(aes(color=strata,group=strata),size = 0.6) + -->
<!--   scale_x_continuous(name='Years since diagnosis') + -->
<!--   scale_y_continuous(name='Predicted hazard') + -->
<!--   ggtitle("Predicted Hazard") + -->
<!--   theme(plot.title = element_text(hjust = 0.5)) -->
<!-- ``` -->
<!-- # 6. Model performance -->
<!-- ## 6.1 Internal comparison -->
<!-- ### 6.1.1 Accurancy: -->
<!-- For the non-penalized method, the estimation is largely depended on the number of knots chosen in the B-Spline base function. -->
<!-- The example shown above is using the default knots, which is `nspline=8`. -->
<!-- However, the estimation could be largely different if we choose other knots. -->
<!-- Following is the code showing the performance of the estimation when choosing different knots: -->
<!-- Following is the code showing the performance of the estimation when choosing different knots: -->
<!-- ```{r} -->
<!-- sim_data=surtvep::sim_data -->
<!-- event=sim_data[,"event"] -->
<!-- time=sim_data[,"time"] -->
<!-- data=sim_data[,!colnames(sim_data) %in% c("event","time")] -->
<!-- knot_list=c(6,8,10,20) -->
<!-- labels=paste0("Knots=",knot_list) -->
<!-- x=seq(0,3,length.out=sum(event==1)) -->
<!-- y=1 -->
<!-- for(knot in knot_list){ -->
<!--   fit<-coxtp(event=event,z=data,time=time,nspline=knot) -->
<!--   plot<-coxtp.plot(fit,coef="V1",ylab="HR(log-scale)") + -->
<!--     theme(text = element_text(size = 10), -->
<!--           axis.text.x = element_text(size = 8), -->
<!--           axis.text.y=element_text(size = 8)) + -->
<!--     ggtitle("") + geom_line(aes(x=x,y=y)) -->
<!--   plot -->
<!--   assign(paste0("plot",knot),plot) -->
<!-- } -->
<!-- library(cowplot) -->
<!-- title <- ggdraw() + -->
<!--   draw_label( -->
<!--     "Non-penalized NR", -->
<!--     fontface = 'bold', -->
<!--     x = 0, -->
<!--     hjust = 0, -->
<!--     size=15 -->
<!--   ) + -->
<!--   theme( -->
<!--     plot.margin = margin(0, 0, 0, 7) -->
<!--   ) -->
<!-- ``` -->
<!-- ```{r,fig.height = 7, fig.width = 7, fig.align = "center"} -->
<!-- p1=plot_grid(plot6,plot8,plot10,plot20,ncol=2,labels=c(labels),label_size = 13) -->
<!-- p1 -->
<!-- ``` -->
<!-- For the result above, the red line and shadow refer to the estimated function and 95%CI while the black line refers to the true function which is time-fixed(y=1). -->
<!-- From the result above, we noticed that as the knots increase, the estimation becomes more and more inaccurate. -->
<!-- This is happening because as the number of knots increases, the variance in the data was mistakenly captured as its influence. -->
<!-- This makes the number of knots of selection in the non-penalized model very important. -->
<!-- While for penalized model, since we have penalized term, the number of knots didn't matters much, instead, the $\lambda$ is more important. -->
<!-- Following plot is the performance of estimation when we use the lambda_spline selected before, which is `lambda_spline= 1000` -->
<!-- ```{r} -->
<!-- knot_list=c(6,8,10,20) -->
<!-- labels=paste0("Knots=",knot_list) -->
<!-- x=seq(0,3,length.out=sum(event==1)) -->
<!-- y=1 -->
<!-- for(knot in knot_list){ -->
<!--   fit<-coxtp(event=event,z=data,time=time,nspline=knot,lambda_spline = 1000) -->
<!--   plot<-coxtp.plot(fit,coef="V1",ylab="HR(log-scale)") + -->
<!--     theme(text = element_text(size = 10), -->
<!--           axis.text.x = element_text(size = 8), -->
<!--           axis.text.y=element_text(size = 8)) + -->
<!--     ggtitle("") + -->
<!--     geom_line(aes(x=x,y=y)) -->
<!--   plot -->
<!--   assign(paste0("plot",knot),plot) -->
<!-- } -->
<!-- ``` -->
<!-- ```{r,fig.height = 7, fig.width = 7, fig.align = "center"} -->
<!-- library(cowplot) -->
<!-- title <- ggdraw() + -->
<!--   draw_label( -->
<!--     paste0("Penalized NR,lambda=",1000), -->
<!--     fontface = 'bold', -->
<!--     x = 0, -->
<!--     hjust = 0, -->
<!--     size=15 -->
<!--   ) + -->
<!--   theme( -->
<!--     plot.margin = margin(0, 0, 0, 7) -->
<!--   ) -->
<!-- p1=plot_grid(plot6,plot8,plot10,plot20,ncol=2,labels=c(labels),label_size = 13) -->
<!-- p1 -->
<!-- ``` -->
<p>From the plot above, we could observe that with different knots
selected, the performance is not different so much for different knots,
all the estimates are relatively close to the real function. However, in
the penalized model, the lambda is more important which is another
reason that we need to select the best lambda before actually fitting
the model. The following plot is the performance of different lambda
selected. For the following plot, the knot was set as default, which is
<code>knot=8</code>.</p>
<!-- ```{r} -->
<!-- lambda_spline_all=c(0.001,0.01,0.1,1,10,100) -->
<!-- labels=paste0("lambda=",lambda_spline_all) -->
<!-- i=1 -->
<!-- x=seq(0,3,length.out=sum(event==1)) -->
<!-- y=1 -->
<!-- for(lambda in lambda_spline_all){ -->
<!--   fit<-coxtp(event=event,z=data,time=time,lambda_spline = lambda) -->
<!--   plot<-coxtp.plot(fit,coef="V1",ylab="HR(log-scale)") + -->
<!--     theme(text = element_text(size = 10), -->
<!--           axis.text.x = element_text(size = 8), -->
<!--           axis.text.y=element_text(size = 8)) + -->
<!--     ggtitle("")  + -->
<!--     geom_line(aes(x=x,y=y)) -->
<!--   plot -->
<!--   assign(paste0("plot",i),plot) -->
<!--   i=i+1 -->
<!-- } -->
<!-- library(cowplot) -->
<!-- title <- ggdraw() + -->
<!--   draw_label( -->
<!--     paste0("Penalized NR,knot=",8), -->
<!--     fontface = 'bold', -->
<!--     x = 0, -->
<!--     hjust = 0, -->
<!--     size=15 -->
<!--   ) + -->
<!--   theme( -->
<!--     plot.margin = margin(0, 0, 0, 7) -->
<!--   ) -->
<!-- ``` -->
<!-- ```{r,fig.height = 9, fig.width = 7, fig.align = "center"} -->
<!-- p1=plot_grid(plot1,plot2,plot3,plot4,plot5,plot6,ncol=2,labels=labels,label_size = 13) -->
<!-- p1 -->
<!-- ``` -->
<!-- As a result, as the lambda increase, the estimated function is more related to the true function. -->
<!-- This is happening because that the true function is time-fixed function, thus, as the lambda increase, the real function tends to shrink to the fixed function. -->
<!-- ### 6.1.2 Efficacy -->
<!-- Next, we are going to compare the Efficacy of different methods. -->
<!-- The main function we used to eliminate computation time by parallel. -->
<!-- For the function, the default setting for parallel is `parallel=FALSE`. -->
<!-- For parallel computation, we also need to define `threads`, which refers to the number of cores of the computer. -->
<!-- Here we set `thread=4`. -->
<!-- The following code and plot is to use to compare parallel and non-parallel time for different sample size: -->
<!-- ```{r} -->
<!-- library(stringi) -->
<!-- library(stringr) -->
<!-- library(dplyr) -->
<!-- samplesize_list=c(1000,2000,3000,4000,5000) -->
<!-- i=1 -->
<!-- for(samplesize in samplesize_list){ -->
<!--   print(i) -->
<!--   sim_data_sub=sim_data[1:samplesize,] -->
<!--   event_sub=sim_data_sub[,"event"] -->
<!--   time_sub=sim_data_sub[,"time"] -->
<!--   data_sub=sim_data_sub[,!colnames(sim_data_sub) %in% c("event","time")] -->
<!--   non_parallel=bench::mark(coxtp(event=event_sub,z=data_sub,time=time_sub,lambda_spline = 100))[,1:8] -->
<!--   parallel=bench::mark(coxtp(event=event_sub,z=data_sub,time=time_sub,lambda_spline = 100,parallel = T,threads = 4))[,1:8] -->
<!--   non_parallel[,1]=samplesize -->
<!--   parallel[,1]=samplesize -->
<!--   if(i!=1){ -->
<!--     non_parallel_list=rbind(non_parallel_list,non_parallel) -->
<!--     parallel_list=rbind(parallel_list,parallel) -->
<!--   } else { -->
<!--     non_parallel_list=non_parallel -->
<!--     parallel_list=parallel -->
<!--   } -->
<!--   i=i+1 -->
<!-- } -->
<!-- parallel_list$parallel="Parallel" -->
<!-- non_parallel_list$parallel="None-Parallel" -->
<!-- time_data=rbind(parallel_list,non_parallel_list) %>% -->
<!--   mutate(median_time=str_remove(median,"s"), -->
<!--          median_time=str_remove(median_time,"m"), -->
<!--          median_time=as.numeric(median_time), -->
<!--          median_time=ifelse(str_detect(median,"ms"),median_time/1000,median_time)) %>% -->
<!--   rename(samplesize=expression) -->
<!-- #Plot Time used: -->
<!-- ``` -->
<!-- ```{r,fig.height = 5, fig.width = 7, fig.align = "center"} -->
<!-- ggplot(time_data,aes(x=samplesize,y=median_time,group=parallel)) + -->
<!--   geom_point(aes(color=parallel)) + -->
<!--   geom_line(aes(color=parallel)) + -->
<!--   labs(x="Sample Size",y="Seconds",title="Internal Computation time Comparison") -->
<!-- ``` -->
<!-- ## 6.2 External comparison -->
<!-- ### 6.2.1 Accurancy -->
<!-- In this section, we are going to compare the performance between our package and other time-varying survival packages. -->
<!-- # 7. Simulation -->
<!-- In this section, we will generate our model prediction to large dataset and illustrate how to do simulation based on our package -->
<!-- To start with, we first divided our dataset into training and testing dataset: -->
<!-- ```{r} -->
<!-- sim_data=sim_data_p5 -->
<!-- #Generate ID for sampling -->
<!-- sim_data=cbind(sim_data,c(1:nrow(sim_data))) -->
<!-- train_id=sample(c(1:nrow(sim_data)),2000,replace=F) -->
<!-- train_data=sim_data[sim_data[,8] %in% train_id, ] -->
<!-- test_data=sim_data[!sim_data[,8] %in% train_id, ] -->
<!-- #Remove ID -->
<!-- train_data=train_data[,1:7] -->
<!-- test_data=test_data[,1:7] -->
<!-- ``` -->
<!-- Next, we are going to build the model using the training data. -->
<!-- The step is similar as we have shown in previous step -->
<!-- ```{r} -->
<!-- event=train_data[,"event"] -->
<!-- time=train_data[,"time"] -->
<!-- data=train_data[,!colnames(train_data) %in% c("event","time")] -->
<!-- lambda_spline_all=c(0.001,0.01,0.1,1,10,100,1000) -->
<!-- fit_penalized <- coxtp(event = event, z = data, time = time,lambda_spline=lambda_spline_all) -->
<!-- fit_penalized$lambda.selected -->
<!-- ``` -->
<!-- From the result above, we noticed that the lambda.selected is 1. -->
<!-- Next, we are going to predict the model using the test_data. -->
<!-- Here we are going to treat the `test_data` as a whole new population data and want to predict the event probability by time. -->
<!-- From previous illustration, we know that the function `cox.predict` could generate absolute hazard for one individual during the time period. -->
</div>
</div>
<div class="section level2">
<h2 id="real-data-example-support">Real Data Example <code>SUPPORT</code><a class="anchor" aria-label="anchor" href="#real-data-example-support"></a>
</h2>
<p>In this section, we illustrate the usage of our package by analyzing
the time-varying effects on the real data <code>SUPPORT</code> (Study to
Understand Prognoses Preferences Outcomes and Risks of Treatment). We
use the processed <code>SUPPORT</code> data set included in the R
package <span class="citation">(Bhatnagar et al. 2020)</span>.</p>
<p>We study the time-varying effects of metastatic cancer as the
illustration example and include</p>
<p>First we load the data and get the survival outcome:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">support</span><span class="op">)</span></span>
<span></span>
<span><span class="va">time</span> <span class="op">&lt;-</span> <span class="va">support</span><span class="op">$</span><span class="va">d.time</span></span>
<span><span class="va">death</span> <span class="op">&lt;-</span> <span class="va">support</span><span class="op">$</span><span class="va">death</span></span></code></pre></div>
<p>Age, cancer status and diabetes status are included as covariates and
considered as categorical variables. Age has 4 levels, cancer status has
3 levels and diabetes has 2 levels. The following codes processed the
covariates for model fitting.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#diabetes: </span></span>
<span><span class="va">diabetes</span> <span class="op">&lt;-</span>  <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html" class="external-link">model.matrix</a></span><span class="op">(</span><span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">support</span><span class="op">$</span><span class="va">diabetes</span><span class="op">)</span><span class="op">)</span><span class="op">[</span>,<span class="op">-</span><span class="fl">1</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#sex: female as the reference group</span></span>
<span><span class="va">sex</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html" class="external-link">model.matrix</a></span><span class="op">(</span><span class="op">~</span><span class="va">support</span><span class="op">$</span><span class="va">sex</span><span class="op">)</span><span class="op">[</span>,<span class="op">-</span><span class="fl">1</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#age: continuous variable</span></span>
<span><span class="va">age</span> <span class="op">&lt;-</span><span class="va">support</span><span class="op">$</span><span class="va">age</span></span>
<span><span class="va">age</span><span class="op">[</span><span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&lt;=</span><span class="fl">50</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"&lt;50"</span></span>
<span><span class="va">age</span><span class="op">[</span><span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&gt;</span><span class="fl">50</span> <span class="op">&amp;</span> <span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&lt;=</span><span class="fl">60</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"50-59"</span></span>
<span><span class="va">age</span><span class="op">[</span><span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&gt;</span><span class="fl">60</span> <span class="op">&amp;</span> <span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&lt;</span><span class="fl">70</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"60-69"</span></span>
<span><span class="va">age</span><span class="op">[</span><span class="va">support</span><span class="op">$</span><span class="va">age</span><span class="op">&gt;=</span><span class="fl">70</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"70+"</span></span>
<span><span class="va">age</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">age</span>, levels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"60-69"</span>, <span class="st">"&lt;50"</span>, <span class="st">"50-59"</span>, <span class="st">"70+"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">z_age</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html" class="external-link">model.matrix</a></span><span class="op">(</span><span class="op">~</span><span class="va">age</span><span class="op">)</span><span class="op">[</span>,<span class="op">-</span><span class="fl">1</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># cancer status: metastatic, yes, no</span></span>
<span><span class="va">ca</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">support</span><span class="op">$</span><span class="va">ca</span><span class="op">)</span></span>
<span><span class="co"># levels(ca) &lt;- c("non_metastatic",  "metastatic")</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/levels.html" class="external-link">levels</a></span><span class="op">(</span><span class="va">ca</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"metastatic"</span>,  <span class="st">"no"</span>, <span class="st">"yes"</span><span class="op">)</span></span>
<span><span class="va">z_ca</span> <span class="op">&lt;-</span>  <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html" class="external-link">model.matrix</a></span><span class="op">(</span><span class="op">~</span><span class="va">ca</span><span class="op">)</span><span class="op">[</span>,<span class="op">-</span><span class="fl">1</span><span class="op">]</span></span>
<span></span>
<span><span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">z_age</span>, <span class="va">z_ca</span>, <span class="va">sex</span>, <span class="va">diabetes</span><span class="op">)</span></span>
<span><span class="co"># colnames(z) &lt;- c("age_50", "age_50_59", "age_70", "metastatic", "diabetes", "male")</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">z</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"age_50"</span>, <span class="st">"age_50_59"</span>, <span class="st">"age_70"</span>, <span class="st">"non_cancer"</span>, <span class="st">"non_metastatic"</span>, <span class="st">"diabetes"</span>, <span class="st">"male"</span><span class="op">)</span></span></code></pre></div>
<p>First we take a look at the Kaplan-Meier plots. The following code
produces the K-M plots for three categorical variable mentioned
above.</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://rpkgs.datanovia.com/survminer/index.html" class="external-link">survminer</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning: package 'survminer' was built under R version 4.1.3</span></span>
<span><span class="co">#&gt; Warning: package 'ggpubr' was built under R version 4.1.3</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/therneau/survival" class="external-link">survival</a></span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">death</span>, <span class="va">z</span><span class="op">)</span></span>
<span><span class="va">fit1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/survfit.html" class="external-link">survfit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">death</span><span class="op">)</span> <span class="op">~</span> <span class="va">non_cancer</span> <span class="op">+</span> <span class="va">non_metastatic</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="va">fit2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/survfit.html" class="external-link">survfit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">death</span><span class="op">)</span> <span class="op">~</span> <span class="va">diabetes</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="va">fit3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survival/man/survfit.html" class="external-link">survfit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/survival/man/Surv.html" class="external-link">Surv</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">death</span><span class="op">)</span> <span class="op">~</span> <span class="va">age_50</span> <span class="op">+</span> <span class="va">age_50_59</span> <span class="op">+</span> <span class="va">age_70</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survminer/man/ggsurvplot.html" class="external-link">ggsurvplot</a></span><span class="op">(</span><span class="va">fit1</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-31-1.png" width="700"></p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/survminer/man/ggsurvplot.html" class="external-link">ggsurvplot</a></span><span class="op">(</span><span class="va">fit1</span>, data <span class="op">=</span> <span class="va">data</span>, legend.labs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"non-metastatic"</span>, <span class="st">"metastatic"</span>, <span class="st">"non-cancer"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-31-2.png" width="700"></p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/survminer/man/ggsurvplot.html" class="external-link">ggsurvplot</a></span><span class="op">(</span><span class="va">fit2</span>, data <span class="op">=</span> <span class="va">data</span>, legend.labs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"diabetes"</span>, <span class="st">"non-diabetes"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-31-3.png" width="700"></p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/survminer/man/ggsurvplot.html" class="external-link">ggsurvplot</a></span><span class="op">(</span><span class="va">fit3</span>, data <span class="op">=</span> <span class="va">data</span>, legend.labs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"60-69"</span>, <span class="st">"70+"</span>, <span class="st">"50-59"</span>, <span class="st">"&lt;50"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-31-4.png" width="700"></p>
<p>Fit the Newtons’ Method using <code>coxtv</code>:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.coxtv</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtv.html">coxtv</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">death</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time</span>, nsplines <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -5.7809097; Stopping crit = 8.5517105e-02;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -5.7668975; Stopping crit = 1.3701217e-02;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -5.7668366; Stopping crit = 5.9791110e-05;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -5.7668365; Stopping crit = 1.0851983e-07;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -5.7668365; Stopping crit = 1.3509639e-11;</span></span></code></pre></div>
<p>We take a look at the estimation plots of cancer status using the
<code>plot</code> function:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fit.coxtv</span>, parm <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"non_cancer"</span>, <span class="st">"non_metastatic"</span><span class="op">)</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-33-1.png" width="700"></p>
<p>Non-metastatic cancer, also known as earlier stage cancer, refers to
cancer that is confined to the primary site and has not spread to other
parts of the body.</p>
<p>Non-cancer refers to the absence of cancer in a person. It may also
refer to benign tumors or abnormal growths that are not cancerous.</p>
<p>Conditioned on the diabetes status and age, we can see the
proportional hazards assumption for cancer status is clearly not
satisfied. There is a strong difference in the hazard of death from
cancer between metastatic cancer, non-metastatic cancer and non-cancer.
Patients with metastatic cancer has a higher hazard of dying in the
first 1500 days.</p>
<p>Then we add penalty term to improve the estimation.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit.coxtp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/coxtp.html">coxtp</a></span><span class="op">(</span>event <span class="op">=</span> <span class="va">death</span>, z <span class="op">=</span> <span class="va">z</span>, time <span class="op">=</span> <span class="va">time</span>, lambda <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">10</span>,<span class="fl">100</span>,<span class="fl">1000</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -5.7812444; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -5.7671833; Stopping crit = 1.9641985e-01;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -5.7671236; Stopping crit = 8.3228788e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -5.7671235; Stopping crit = 1.7829964e-06;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -5.7671235; Stopping crit = 1.4411016e-10;</span></span>
<span><span class="co">#&gt; lambda 1 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -5.7812468; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -5.7671838; Stopping crit = 1.9644601e-01;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -5.7671242; Stopping crit = 8.3214259e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -5.7671241; Stopping crit = 1.7319602e-06;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -5.7671516; Stopping crit = 3.8334108e-04;</span></span>
<span><span class="co">#&gt; Iter 6: Obj fun = -5.7671241; Stopping crit = 3.8319360e-04;</span></span>
<span><span class="co">#&gt; Iter 7: Obj fun = -5.7671241; Stopping crit = 2.4793353e-13;</span></span>
<span><span class="co">#&gt; lambda 10 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -5.7812821; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -5.7672134; Stopping crit = 1.9660829e-01;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -5.7671538; Stopping crit = 8.3172929e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -5.7671537; Stopping crit = 1.4760428e-06;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -5.7673032; Stopping crit = 2.0917439e-03;</span></span>
<span><span class="co">#&gt; Iter 6: Obj fun = -5.7671537; Stopping crit = 2.0873733e-03;</span></span>
<span><span class="co">#&gt; Iter 7: Obj fun = -5.7671537; Stopping crit = 7.3170615e-13;</span></span>
<span><span class="co">#&gt; lambda 100 is done.</span></span>
<span><span class="co">#&gt; Iter 1: Obj fun = -5.7814715; Stopping crit = 1.0000000e+00;</span></span>
<span><span class="co">#&gt; Iter 2: Obj fun = -5.7674149; Stopping crit = 1.9699357e-01;</span></span>
<span><span class="co">#&gt; Iter 3: Obj fun = -5.7673556; Stopping crit = 8.3018593e-04;</span></span>
<span><span class="co">#&gt; Iter 4: Obj fun = -5.7673555; Stopping crit = 1.3357418e-06;</span></span>
<span><span class="co">#&gt; Iter 5: Obj fun = -5.7675285; Stopping crit = 2.4280730e-03;</span></span>
<span><span class="co">#&gt; Iter 6: Obj fun = -5.7673555; Stopping crit = 2.4221855e-03;</span></span>
<span><span class="co">#&gt; Iter 7: Obj fun = -5.7673555; Stopping crit = 1.0322577e-12;</span></span>
<span><span class="co">#&gt; lambda 1000 is done.</span></span>
<span><span class="va">IC.support</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/IC.html">IC</a></span><span class="op">(</span><span class="va">fit.coxtp</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">IC.support</span><span class="op">$</span><span class="va">model.mAIC</span>, parm <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"non_cancer"</span>, <span class="st">"non_metastatic"</span><span class="op">)</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-35-1.png" width="700"></p>
<p>Then we provide the hypothesis testing for each covariate.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#test the proportional hazards assumption</span></span>
<span><span class="va">test.ph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.ph.html">tvef.ph</a></span><span class="op">(</span><span class="va">fit.coxtv</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">test.ph</span><span class="op">)</span></span>
<span><span class="co">#&gt;                    chisq df            p</span></span>
<span><span class="co">#&gt; age_50          46.31117  9 5.271760e-07</span></span>
<span><span class="co">#&gt; age_50_59       13.20847  9 1.533978e-01</span></span>
<span><span class="co">#&gt; age_70           3.33877  9 9.493378e-01</span></span>
<span><span class="co">#&gt; non_cancer     389.78944  9 2.064355e-78</span></span>
<span><span class="co">#&gt; non_metastatic 210.60227  9 1.975632e-40</span></span>
<span><span class="co">#&gt; diabetes        19.01802  9 2.504010e-02</span></span>
<span><span class="co">#&gt; male            44.47614  9 1.153035e-06</span></span>
<span></span>
<span><span class="co">#test the significance of each covariate</span></span>
<span><span class="va">test.zero</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tvef.zero.html">tvef.zero</a></span><span class="op">(</span><span class="va">fit.coxtv</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">test.zero</span><span class="op">)</span></span>
<span><span class="co">#&gt;                    chisq df             p</span></span>
<span><span class="co">#&gt; age_50          92.95934 10  1.384020e-15</span></span>
<span><span class="co">#&gt; age_50_59       23.20617 10  1.001062e-02</span></span>
<span><span class="co">#&gt; age_70          33.59559 10  2.162004e-04</span></span>
<span><span class="co">#&gt; non_cancer     997.76510 10 5.666717e-208</span></span>
<span><span class="co">#&gt; non_metastatic 242.09638 10  2.486165e-46</span></span>
<span><span class="co">#&gt; diabetes        25.96236 10  3.791138e-03</span></span>
<span><span class="co">#&gt; male            48.35095 10  5.354766e-07</span></span></code></pre></div>
<p>When testing for the proportional hazards assumption, age_50,
non_cancer, non_metastatic, diabetes and male has p-value &lt; 0.05. We
reject the null hypothesis and claim that these covariates have violated
the proportional hazards assumption.</p>
<p>All these covariates are significant based on the Wald test.</p>
<p>Then we can use the following codes to get the baseline estimation
and the baseline plot.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/baseline.html">baseline</a></span><span class="op">(</span><span class="va">IC.support</span><span class="op">$</span><span class="va">model.TIC</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">base</span><span class="op">)</span></span></code></pre></div>
<p><img src="surtvep_files/figure-html/unnamed-chunk-38-1.png" width="700"></p>
<p>When dealing with data where ties are presented, we can also give
baseline hazard and absolute hazard for each covariate.</p>
<p>We uti</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">time.discrete</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">support</span><span class="op">$</span><span class="va">d.time</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>The following codes provide the absolute hazards plot.</p>
<p>Age, cancer status and diabetes status are included as covariates and
considered as categorical variables. Age has 4 levels, cancer status has
3 levels and diabetes has 2 levels. The following codes processed the
covariates for model fitting.</p>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-casebase" class="csl-entry">
Bhatnagar, Sahir, Maxime Turgeon, Jesse Islam, Olli Saarela, and James
Hanley. 2020. <span>“Casebase: Fitting Flexible Smooth-in-Time Hazards
and Risk Functions via Logistic and Multinomial Regression.”</span> <a href="https://CRAN.R-project.org/package=casebase" class="external-link">https://CRAN.R-project.org/package=casebase</a>.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Lingfeng Luo, Wenbo Wu, Xueting Tao.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.6.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
